/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * weather.gov API
 * weather.gov API
 *
 * OpenAPI spec version: 1.8.5
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import { default as isomorphicFetch } from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.weather.gov".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 * An object representing a public alert message. Unless otherwise noted, the fields in this object correspond to the National Weather Service CAP v1.2 specification, which extends the OASIS Common Alerting Protocol (CAP) v1.2 specification and USA Integrated Public Alert and Warning System (IPAWS) Profile v1.0. Refer to this documentation for more complete information. http://docs.oasis-open.org/emergency/cap/v1.2/CAP-v1.2-os.html http://docs.oasis-open.org/emergency/cap/v1.2/ipaws-profile/v1.0/cs01/cap-v1.2-ipaws-profile-cs01.html https://alerts.weather.gov/#technical-notes-v12
 * @export
 * @interface Alert
 */
export interface Alert {
  /**
   *
   * @type {AlertId}
   * @memberof Alert
   */
  id?: AlertId;
  /**
   * A textual description of the area affected by the alert.
   * @type {string}
   * @memberof Alert
   */
  areaDesc?: string;
  /**
   *
   * @type {AlertGeocode}
   * @memberof Alert
   */
  geocode?: AlertGeocode;
  /**
   * An array of API links for zones affected by the alert. This is an API-specific extension field and is not part of the CAP specification.
   * @type {Array<string>}
   * @memberof Alert
   */
  affectedZones?: Array<string>;
  /**
   * A list of prior alerts that this alert updates or replaces.
   * @type {Array<AlertReferences>}
   * @memberof Alert
   */
  references?: Array<AlertReferences>;
  /**
   * The time of the origination of the alert message.
   * @type {Date}
   * @memberof Alert
   */
  sent?: Date;
  /**
   * The effective time of the information of the alert message.
   * @type {Date}
   * @memberof Alert
   */
  effective?: Date;
  /**
   * The expected time of the beginning of the subject event of the alert message.
   * @type {Date}
   * @memberof Alert
   */
  onset?: Date;
  /**
   * The expiry time of the information of the alert message.
   * @type {Date}
   * @memberof Alert
   */
  expires?: Date;
  /**
   * The expected end time of the subject event of the alert message.
   * @type {Date}
   * @memberof Alert
   */
  ends?: Date;
  /**
   *
   * @type {AlertStatus}
   * @memberof Alert
   */
  status?: AlertStatus;
  /**
   *
   * @type {AlertMessageType}
   * @memberof Alert
   */
  messageType?: AlertMessageType;
  /**
   * The code denoting the category of the subject event of the alert message.
   * @type {string}
   * @memberof Alert
   */
  category?: Alert.CategoryEnum;
  /**
   *
   * @type {AlertSeverity}
   * @memberof Alert
   */
  severity?: AlertSeverity;
  /**
   *
   * @type {AlertCertainty}
   * @memberof Alert
   */
  certainty?: AlertCertainty;
  /**
   *
   * @type {AlertUrgency}
   * @memberof Alert
   */
  urgency?: AlertUrgency;
  /**
   * The text denoting the type of the subject event of the alert message.
   * @type {string}
   * @memberof Alert
   */
  event?: string;
  /**
   * Email address of the NWS webmaster.
   * @type {string}
   * @memberof Alert
   */
  sender?: string;
  /**
   * The text naming the originator of the alert message.
   * @type {string}
   * @memberof Alert
   */
  senderName?: string;
  /**
   * The text headline of the alert message.
   * @type {string}
   * @memberof Alert
   */
  headline?: string;
  /**
   * The text describing the subject event of the alert message.
   * @type {string}
   * @memberof Alert
   */
  description?: string;
  /**
   * The text describing the recommended action to be taken by recipients of the alert message.
   * @type {string}
   * @memberof Alert
   */
  instruction?: string;
  /**
   * The code denoting the type of action recommended for the target audience. This corresponds to responseType in the CAP specification.
   * @type {string}
   * @memberof Alert
   */
  response?: Alert.ResponseEnum;
  /**
   * System-specific additional parameters associated with the alert message. The keys in this object correspond to parameter definitions in the NWS CAP specification.
   * @type {{ [key: string]: Array; }}
   * @memberof Alert
   */
  parameters?: { [key: string]: Array<any> };
}

/**
 * @export
 * @namespace Alert
 */
export namespace Alert {
  /**
   * @export
   * @enum {string}
   */
  export enum CategoryEnum {
    Met = <any>"Met",
    Geo = <any>"Geo",
    Safety = <any>"Safety",
    Security = <any>"Security",
    Rescue = <any>"Rescue",
    Fire = <any>"Fire",
    Health = <any>"Health",
    Env = <any>"Env",
    Transport = <any>"Transport",
    Infra = <any>"Infra",
    CBRNE = <any>"CBRNE",
    Other = <any>"Other",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ResponseEnum {
    Shelter = <any>"Shelter",
    Evacuate = <any>"Evacuate",
    Prepare = <any>"Prepare",
    Execute = <any>"Execute",
    Avoid = <any>"Avoid",
    Monitor = <any>"Monitor",
    Assess = <any>"Assess",
    AllClear = <any>"AllClear",
    None = <any>"None",
  }
}
/**
 * An alert entry in an Atom feed
 * @export
 * @interface AlertAtomEntry
 */
export interface AlertAtomEntry {
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  updated?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  published?: string;
  /**
   *
   * @type {AlertAtomEntryAuthor}
   * @memberof AlertAtomEntry
   */
  author?: AlertAtomEntryAuthor;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  summary?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  event?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  sent?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  effective?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  expires?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  status?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  msgType?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  urgency?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  severity?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  certainty?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  areaDesc?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntry
   */
  polygon?: string;
  /**
   *
   * @type {Array<AlertXMLParameter>}
   * @memberof AlertAtomEntry
   */
  geocode?: Array<AlertXMLParameter>;
  /**
   *
   * @type {Array<AlertXMLParameter>}
   * @memberof AlertAtomEntry
   */
  parameter?: Array<AlertXMLParameter>;
}
/**
 *
 * @export
 * @interface AlertAtomEntryAuthor
 */
export interface AlertAtomEntryAuthor {
  /**
   *
   * @type {string}
   * @memberof AlertAtomEntryAuthor
   */
  name?: string;
}
/**
 * An alert feed in Atom format
 * @export
 * @interface AlertAtomFeed
 */
export interface AlertAtomFeed {
  /**
   *
   * @type {string}
   * @memberof AlertAtomFeed
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomFeed
   */
  generator?: string;
  /**
   *
   * @type {string}
   * @memberof AlertAtomFeed
   */
  updated?: string;
  /**
   *
   * @type {AlertAtomFeedAuthor}
   * @memberof AlertAtomFeed
   */
  author?: AlertAtomFeedAuthor;
  /**
   *
   * @type {string}
   * @memberof AlertAtomFeed
   */
  title?: string;
  /**
   *
   * @type {Array<AlertAtomEntry>}
   * @memberof AlertAtomFeed
   */
  entry?: Array<AlertAtomEntry>;
}
/**
 *
 * @export
 * @interface AlertAtomFeedAuthor
 */
export interface AlertAtomFeedAuthor {
  /**
   *
   * @type {string}
   * @memberof AlertAtomFeedAuthor
   */
  name?: string;
}
/**
 *
 * @export
 * @interface AlertCap
 */
export interface AlertCap {}
/**
 *
 * @export
 * @enum {string}
 */
export enum AlertCertainty {
  Observed = <any>"Observed",
  Likely = <any>"Likely",
  Possible = <any>"Possible",
  Unlikely = <any>"Unlikely",
  Unknown = <any>"Unknown",
}
/**
 *
 * @export
 * @interface AlertCollection
 */
export interface AlertCollection {
  /**
   * A title describing the alert collection
   * @type {string}
   * @memberof AlertCollection
   */
  title?: string;
  /**
   * The last time a change occurred to this collection
   * @type {Date}
   * @memberof AlertCollection
   */
  updated?: Date;
  /**
   *
   * @type {AlertCollectionPagination}
   * @memberof AlertCollection
   */
  pagination?: AlertCollectionPagination;
}
/**
 *
 * @export
 * @interface AlertCollectionGeoJson
 */
export interface AlertCollectionGeoJson extends GeoJsonFeatureCollection {
  /**
   * A title describing the alert collection
   * @type {string}
   * @memberof AlertCollectionGeoJson
   */
  title?: string;
  /**
   * The last time a change occurred to this collection
   * @type {Date}
   * @memberof AlertCollectionGeoJson
   */
  updated?: Date;
  /**
   *
   * @type {AlertCollectionPagination}
   * @memberof AlertCollectionGeoJson
   */
  pagination?: AlertCollectionPagination;
  /**
   *
   * @type {Array<AlertCollectionGeoJsonFeatures>}
   * @memberof AlertCollectionGeoJson
   */
  features: Array<GeoJsonFeature>;
}
/**
 *
 * @export
 * @interface AlertCollectionJsonLd
 */
export interface AlertCollectionJsonLd extends AlertCollection {
  /**
   *
   * @type {JsonLdContext}
   * @memberof AlertCollectionJsonLd
   */
  context?: JsonLdContext;
  /**
   *
   * @type {Array<Alert>}
   * @memberof AlertCollectionJsonLd
   */
  graph?: Array<Alert>;
}
/**
 * Links for retrieving more data
 * @export
 * @interface AlertCollectionPagination
 */
export interface AlertCollectionPagination {
  /**
   * A link to the next set of alerts
   * @type {string}
   * @memberof AlertCollectionPagination
   */
  next: string;
}
/**
 *
 * @export
 * @interface AlertGeoJson
 */
export interface AlertGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {Alert}
   * @memberof AlertGeoJson
   */
  properties: Alert;
}

/**
 * @export
 * @namespace AlertGeoJson
 */
export namespace AlertGeoJson {}
/**
 * Lists of codes for NWS public zones and counties affected by the alert.
 * @export
 * @interface AlertGeocode
 */
export interface AlertGeocode {
  /**
   * A list of NWS public zone or county identifiers.
   * @type {Array<NWSZoneID>}
   * @memberof AlertGeocode
   */
  UGC?: Array<NWSZoneID>;
  /**
   * A list of SAME (Specific Area Message Encoding) codes for affected counties.
   * @type {Array<string>}
   * @memberof AlertGeocode
   */
  SAME?: Array<string>;
}
/**
 * The identifier of the alert message.
 * @export
 */
export type AlertId = string;
/**
 *
 * @export
 * @interface AlertJsonLd
 */
export interface AlertJsonLd {
  /**
   *
   * @type {Array<Alert>}
   * @memberof AlertJsonLd
   */
  graph?: Array<Alert>;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum AlertMessageType {
  Alert = <any>"Alert",
  Update = <any>"Update",
  Cancel = <any>"Cancel",
  Ack = <any>"Ack",
  Error = <any>"Error",
}
/**
 *
 * @export
 * @interface AlertReferences
 */
export interface AlertReferences {
  /**
   * An API link to the prior alert.
   * @type {string}
   * @memberof AlertReferences
   */
  id?: string;
  /**
   *
   * @type {AlertId}
   * @memberof AlertReferences
   */
  identifier?: AlertId;
  /**
   * The sender of the prior alert.
   * @type {string}
   * @memberof AlertReferences
   */
  sender?: string;
  /**
   * The time the prior alert was sent.
   * @type {Date}
   * @memberof AlertReferences
   */
  sent?: Date;
}
/**
 *
 * @export
 * @enum {string}
 */
export enum AlertSeverity {
  Extreme = <any>"Extreme",
  Severe = <any>"Severe",
  Moderate = <any>"Moderate",
  Minor = <any>"Minor",
  Unknown = <any>"Unknown",
}
/**
 *
 * @export
 * @enum {string}
 */
export enum AlertStatus {
  Actual = <any>"Actual",
  Exercise = <any>"Exercise",
  System = <any>"System",
  Test = <any>"Test",
  Draft = <any>"Draft",
}
/**
 *
 * @export
 * @enum {string}
 */
export enum AlertUrgency {
  Immediate = <any>"Immediate",
  Expected = <any>"Expected",
  Future = <any>"Future",
  Past = <any>"Past",
  Unknown = <any>"Unknown",
}
/**
 *
 * @export
 * @interface AlertXMLParameter
 */
export interface AlertXMLParameter {
  /**
   *
   * @type {string}
   * @memberof AlertXMLParameter
   */
  valueName?: string;
  /**
   *
   * @type {string}
   * @memberof AlertXMLParameter
   */
  value?: string;
}
/**
 * State/territory codes and marine area codes
 * @export
 * @interface AreaCode
 */
export type AreaCode = StateTerritoryCode | MarineAreaCode;
/**
 *
 * @export
 */
export type BinaryFile = string;
/**
 * A GeoJSON bounding box. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 */
export type GeoJsonBoundingBox = Array<number>;
/**
 * A GeoJSON coordinate. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 */
export type GeoJsonCoordinate = Array<number>;
/**
 * A GeoJSON feature. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 * @interface GeoJsonFeature
 */
export interface GeoJsonFeature {
  /**
   *
   * @type {JsonLdContext}
   * @memberof GeoJsonFeature
   */
  context?: JsonLdContext;
  /**
   *
   * @type {string}
   * @memberof GeoJsonFeature
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof GeoJsonFeature
   */
  type: GeoJsonFeature.TypeEnum;
  /**
   *
   * @type {GeoJsonGeometry}
   * @memberof GeoJsonFeature
   */
  geometry: GeoJsonGeometry;
  /**
   *
   * @type {any}
   * @memberof GeoJsonFeature
   */
  properties: any;
}

/**
 * @export
 * @namespace GeoJsonFeature
 */
export namespace GeoJsonFeature {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    Feature = <any>"Feature",
  }
}
/**
 * A GeoJSON feature collection. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 * @interface GeoJsonFeatureCollection
 */
export interface GeoJsonFeatureCollection {
  /**
   *
   * @type {JsonLdContext}
   * @memberof GeoJsonFeatureCollection
   */
  context?: JsonLdContext;
  /**
   *
   * @type {string}
   * @memberof GeoJsonFeatureCollection
   */
  type: GeoJsonFeatureCollection.TypeEnum;
  /**
   *
   * @type {Array<GeoJsonFeature>}
   * @memberof GeoJsonFeatureCollection
   */
  features: Array<GeoJsonFeature>;
}

/**
 * @export
 * @namespace GeoJsonFeatureCollection
 */
export namespace GeoJsonFeatureCollection {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    FeatureCollection = <any>"FeatureCollection",
  }
}
/**
 * A GeoJSON geometry object. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 * @interface GeoJsonGeometry
 */
export interface GeoJsonGeometry {}
/**
 * A GeoJSON line string. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 */
export type GeoJsonLineString = Array<GeoJsonCoordinate>;
/**
 * A GeoJSON polygon. Please refer to IETF RFC 7946 for information on the GeoJSON format.
 * @export
 */
export type GeoJsonPolygon = Array<any>;
/**
 * A geometry represented in Well-Known Text (WKT) format.
 * @export
 */
export type GeometryString = string;
/**
 * Raw forecast data for a 2.5km grid square. This is a list of all potential data layers that may appear. Some layers may not be present in all areas. * temperature * dewpoint * maxTemperature * minTemperature * relativeHumidity * apparentTemperature * heatIndex * windChill * skyCover * windDirection * windSpeed * windGust * weather * hazards: Watch and advisory products in effect * probabilityOfPrecipitation * quantitativePrecipitation * iceAccumulation * snowfallAmount * snowLevel * ceilingHeight * visibility * transportWindSpeed * transportWindDirection * mixingHeight * hainesIndex * lightningActivityLevel * twentyFootWindSpeed * twentyFootWindDirection * waveHeight * wavePeriod * waveDirection * primarySwellHeight * primarySwellDirection * secondarySwellHeight * secondarySwellDirection * wavePeriod2 * windWaveHeight * dispersionIndex * pressure: Barometric pressure * probabilityOfTropicalStormWinds * probabilityOfHurricaneWinds * potentialOf15mphWinds * potentialOf25mphWinds * potentialOf35mphWinds * potentialOf45mphWinds * potentialOf20mphWindGusts * potentialOf30mphWindGusts * potentialOf40mphWindGusts * potentialOf50mphWindGusts * potentialOf60mphWindGusts * grasslandFireDangerIndex * probabilityOfThunder * davisStabilityIndex * atmosphericDispersionIndex * lowVisibilityOccurrenceRiskIndex * stability * redFlagThreatIndex
 * @export
 * @interface Gridpoint
 */
export interface Gridpoint {
  "@context": JsonLdContext;
  geometry: GeometryString;
  "@id": string;
  "@type": any;
  updateTime: string;
  validTimes: ISO8601Interval;
  elevation: QuantitativeValue;
  forecastOffice: string;
  gridId: string;
  gridX: number;
  gridY: number;
  weather: GridpointWeatherValues;
  hazards: GridpointHazardsValues;
}
/**
 * A multi-day forecast for a 2.5km grid square.
 * @export
 * @interface GridpointForecast
 */
export interface GridpointForecast {
  /**
   *
   * @type {JsonLdContext}
   * @memberof GridpointForecast
   */
  context?: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof GridpointForecast
   */
  geometry?: GeometryString;
  /**
   *
   * @type {GridpointForecastUnits}
   * @memberof GridpointForecast
   */
  units?: GridpointForecastUnits;
  /**
   * The internal generator class used to create the forecast text (used for NWS debugging).
   * @type {string}
   * @memberof GridpointForecast
   */
  forecastGenerator?: string;
  /**
   * The time this forecast data was generated.
   * @type {Date}
   * @memberof GridpointForecast
   */
  generatedAt?: Date;
  /**
   * The last update time of the data this forecast was generated from.
   * @type {Date}
   * @memberof GridpointForecast
   */
  updateTime?: Date;
  /**
   * This property is deprecated (use updateTime instead).
   * @type {Date}
   * @memberof GridpointForecast
   */
  updated?: Date;
  /**
   *
   * @type {ISO8601Interval}
   * @memberof GridpointForecast
   */
  validTimes?: ISO8601Interval;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof GridpointForecast
   */
  elevation?: QuantitativeValue;
  /**
   * An array of forecast periods.
   * @type {Array<GridpointForecastPeriod>}
   * @memberof GridpointForecast
   */
  periods?: Array<GridpointForecastPeriod>;
}
/**
 *
 * @export
 * @interface GridpointForecastGeoJson
 */
export interface GridpointForecastGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {GridpointForecast}
   * @memberof GridpointForecastGeoJson
   */
  properties: GridpointForecast;
}

/**
 * @export
 * @namespace GridpointForecastGeoJson
 */
export namespace GridpointForecastGeoJson {}
/**
 *
 * @export
 * @interface GridpointForecastJsonLd
 */
export interface GridpointForecastJsonLd extends GridpointForecast {
  /**
   *
   * @type {JsonLdContext}
   * @memberof GridpointForecastJsonLd
   */
  context: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof GridpointForecastJsonLd
   */
  geometry: GeometryString;
}
/**
 * An object containing forecast information for a specific time period (generally 12-hour or 1-hour).
 * @export
 * @interface GridpointForecastPeriod
 */
export interface GridpointForecastPeriod {
  /**
   * Sequential period number.
   * @type {number}
   * @memberof GridpointForecastPeriod
   */
  number?: number;
  /**
   * A textual identifier for the period. This value will not be present for hourly forecasts.
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  name?: string;
  /**
   * The starting time that this forecast period is valid for.
   * @type {Date}
   * @memberof GridpointForecastPeriod
   */
  startTime?: Date;
  /**
   * The ending time that this forecast period is valid for.
   * @type {Date}
   * @memberof GridpointForecastPeriod
   */
  endTime?: Date;
  /**
   * Indicates whether this period is daytime or nighttime.
   * @type {boolean}
   * @memberof GridpointForecastPeriod
   */
  isDaytime?: boolean;
  /**
   * High/low temperature for the period, depending on whether the period is day or night. This property as an integer value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the \"forecast_temperature_qv\" feature flag on the request.
   * @type {QuantitativeValue | number}
   * @memberof GridpointForecastPeriod
   */
  temperature?: QuantitativeValue | number;
  /**
   * The unit of the temperature value (Fahrenheit or Celsius). This property is deprecated. Future versions will indicate the unit within the quantitative value object for the temperature property. To make use of the future standard format now, set the \"forecast_temperature_qv\" feature flag on the request.
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  temperatureUnit?: GridpointForecastPeriod.TemperatureUnitEnum;
  /**
   * If not null, indicates a non-diurnal temperature trend for the period (either rising temperature overnight, or falling temperature during the day)
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  temperatureTrend?: GridpointForecastPeriod.TemperatureTrendEnum;
  /**
   * Wind speed for the period. This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the \"forecast_wind_speed_qv\" feature flag on the request.
   * @type {QuantitativeValue | string}
   * @memberof GridpointForecastPeriod
   */
  windSpeed?: QuantitativeValue | string;
  /**
   * Peak wind gust for the period. This property as an string value is deprecated. Future versions will express this value as a quantitative value object. To make use of the future standard format now, set the \"forecast_wind_speed_qv\" feature flag on the request.
   * @type {QuantitativeValue | string}
   * @memberof GridpointForecastPeriod
   */
  windGust?: QuantitativeValue | string;
  /**
   * The prevailing direction of the wind for the period, using a 16-point compass.
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  windDirection?: GridpointForecastPeriod.WindDirectionEnum;
  /**
   * A link to an icon representing the forecast summary.
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  icon?: string;
  /**
   * A brief textual forecast summary for the period.
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  shortForecast?: string;
  /**
   * A detailed textual forecast for the period.
   * @type {string}
   * @memberof GridpointForecastPeriod
   */
  detailedForecast?: string;
}

/**
 * @export
 * @namespace GridpointForecastPeriod
 */
export namespace GridpointForecastPeriod {
  /**
   * @export
   * @enum {string}
   */
  export enum TemperatureUnitEnum {
    F = <any>"F",
    C = <any>"C",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum TemperatureTrendEnum {
    Rising = <any>"rising",
    Falling = <any>"falling",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum WindDirectionEnum {
    N = <any>"N",
    NNE = <any>"NNE",
    NE = <any>"NE",
    ENE = <any>"ENE",
    E = <any>"E",
    ESE = <any>"ESE",
    SE = <any>"SE",
    SSE = <any>"SSE",
    S = <any>"S",
    SSW = <any>"SSW",
    SW = <any>"SW",
    WSW = <any>"WSW",
    W = <any>"W",
    WNW = <any>"WNW",
    NW = <any>"NW",
    NNW = <any>"NNW",
  }
}
/**
 * Denotes the units used in the textual portions of the forecast.
 * @export
 * @enum {string}
 */
export enum GridpointForecastUnits {
  Us = <any>"us",
  Si = <any>"si",
}
/**
 *
 * @export
 * @interface GridpointGeoJson
 */
export interface GridpointGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {Gridpoint}
   * @memberof GridpointGeoJson
   */
  properties: Gridpoint;
}

/**
 * @export
 * @namespace GridpointGeoJson
 */
export namespace GridpointGeoJson {}
/**
 *
 * @export
 * @interface GridpointHazards
 */
export interface GridpointHazards {
  /**
   *
   * @type {Array<GridpointHazardsValues>}
   * @memberof GridpointHazards
   */
  values: Array<GridpointHazardsValues>;
}
/**
 * A value object representing an expected hazard.
 * @export
 * @interface GridpointHazardsValue
 */
export interface GridpointHazardsValue {
  /**
   * Hazard code. This value will correspond to a P-VTEC phenomenon code as defined in NWS Directive 10-1703.
   * @type {string}
   * @memberof GridpointHazardsValue
   */
  phenomenon: string;
  /**
   * Significance code. This value will correspond to a P-VTEC significance code as defined in NWS Directive 10-1703. This will most frequently be \"A\" for a watch or \"Y\" for an advisory.
   * @type {string}
   * @memberof GridpointHazardsValue
   */
  significance: string;
  /**
   * Event number. If this hazard refers to a national or regional center product (such as a Storm Prediction Center convective watch), this value will be the sequence number of that product.
   * @type {number}
   * @memberof GridpointHazardsValue
   */
  eventNumber: number;
}
/**
 *
 * @export
 * @interface GridpointHazardsValues
 */
export interface GridpointHazardsValues {
  /**
   *
   * @type {ISO8601Interval}
   * @memberof GridpointHazardsValues
   */
  validTime: ISO8601Interval;
  /**
   *
   * @type {Array<GridpointHazardsValue>}
   * @memberof GridpointHazardsValues
   */
  value: Array<GridpointHazardsValue>;
}
/**
 *
 * @export
 */
export type GridpointJsonLd = Gridpoint;
/**
 * A gridpoint layer consisting of quantitative values (numeric values with associated units of measure).
 * @export
 * @interface GridpointQuantitativeValueLayer
 */
export interface GridpointQuantitativeValueLayer {
  /**
   *
   * @type {UnitOfMeasure}
   * @memberof GridpointQuantitativeValueLayer
   */
  uom?: UnitOfMeasure;
  /**
   *
   * @type {Array<GridpointQuantitativeValueLayerValues>}
   * @memberof GridpointQuantitativeValueLayer
   */
  values: Array<GridpointQuantitativeValueLayerValues>;
}
/**
 *
 * @export
 * @interface GridpointQuantitativeValueLayerValues
 */
export interface GridpointQuantitativeValueLayerValues {
  /**
   *
   * @type {ISO8601Interval}
   * @memberof GridpointQuantitativeValueLayerValues
   */
  validTime: ISO8601Interval;
  /**
   *
   * @type {number}
   * @memberof GridpointQuantitativeValueLayerValues
   */
  value: number;
}
/**
 *
 * @export
 * @interface GridpointWeather
 */
export interface GridpointWeather {
  /**
   *
   * @type {Array<GridpointWeatherValues>}
   * @memberof GridpointWeather
   */
  values: Array<GridpointWeatherValues>;
}
/**
 * A value object representing expected weather phenomena.
 * @export
 * @interface GridpointWeatherValue
 */
export interface GridpointWeatherValue {
  /**
   *
   * @type {string}
   * @memberof GridpointWeatherValue
   */
  coverage: GridpointWeatherValue.CoverageEnum;
  /**
   *
   * @type {string}
   * @memberof GridpointWeatherValue
   */
  weather: GridpointWeatherValue.WeatherEnum;
  /**
   *
   * @type {string}
   * @memberof GridpointWeatherValue
   */
  intensity: GridpointWeatherValue.IntensityEnum;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof GridpointWeatherValue
   */
  visibility: QuantitativeValue;
  /**
   *
   * @type {Array<string>}
   * @memberof GridpointWeatherValue
   */
  attributes: Array<GridpointWeatherValue.AttributesEnum>;
}

/**
 * @export
 * @namespace GridpointWeatherValue
 */
export namespace GridpointWeatherValue {
  /**
   * @export
   * @enum {string}
   */
  export enum CoverageEnum {
    Areas = <any>"areas",
    Brief = <any>"brief",
    Chance = <any>"chance",
    Definite = <any>"definite",
    Few = <any>"few",
    Frequent = <any>"frequent",
    Intermittent = <any>"intermittent",
    Isolated = <any>"isolated",
    Likely = <any>"likely",
    Numerous = <any>"numerous",
    Occasional = <any>"occasional",
    Patchy = <any>"patchy",
    Periods = <any>"periods",
    Scattered = <any>"scattered",
    SlightChance = <any>"slight_chance",
    Widespread = <any>"widespread",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum WeatherEnum {
    BlowingDust = <any>"blowing_dust",
    BlowingSand = <any>"blowing_sand",
    BlowingSnow = <any>"blowing_snow",
    Drizzle = <any>"drizzle",
    Fog = <any>"fog",
    FreezingFog = <any>"freezing_fog",
    FreezingDrizzle = <any>"freezing_drizzle",
    FreezingRain = <any>"freezing_rain",
    FreezingSpray = <any>"freezing_spray",
    Frost = <any>"frost",
    Hail = <any>"hail",
    Haze = <any>"haze",
    IceCrystals = <any>"ice_crystals",
    IceFog = <any>"ice_fog",
    Rain = <any>"rain",
    RainShowers = <any>"rain_showers",
    Sleet = <any>"sleet",
    Smoke = <any>"smoke",
    Snow = <any>"snow",
    SnowShowers = <any>"snow_showers",
    Thunderstorms = <any>"thunderstorms",
    VolcanicAsh = <any>"volcanic_ash",
    WaterSpouts = <any>"water_spouts",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum IntensityEnum {
    VeryLight = <any>"very_light",
    Light = <any>"light",
    Moderate = <any>"moderate",
    Heavy = <any>"heavy",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum AttributesEnum {
    DamagingWind = <any>"damaging_wind",
    DryThunderstorms = <any>"dry_thunderstorms",
    Flooding = <any>"flooding",
    GustyWind = <any>"gusty_wind",
    HeavyRain = <any>"heavy_rain",
    LargeHail = <any>"large_hail",
    SmallHail = <any>"small_hail",
    Tornadoes = <any>"tornadoes",
  }
}
/**
 *
 * @export
 * @interface GridpointWeatherValues
 */
export interface GridpointWeatherValues {
  /**
   *
   * @type {ISO8601Interval}
   * @memberof GridpointWeatherValues
   */
  validTime: ISO8601Interval;
  /**
   *
   * @type {Array<GridpointWeatherValue>}
   * @memberof GridpointWeatherValues
   */
  value: Array<GridpointWeatherValue>;
}
/**
 * A time duration in ISO 8601 format.
 * @export
 */
export type ISO8601Duration = string;
/**
 * A time interval in ISO 8601 format. This can be one of:      1. Start and end time     2. Start time and duration     3. Duration and end time The string \"NOW\" can also be used in place of a start/end time.
 * @export
 * @interface ISO8601Interval
 */
export interface ISO8601Interval {}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   * The total number of active alerts
   * @type {number}
   * @memberof InlineResponse200
   */
  total?: number;
  /**
   * The total number of active alerts affecting land zones
   * @type {number}
   * @memberof InlineResponse200
   */
  land?: number;
  /**
   * The total number of active alerts affecting marine zones
   * @type {number}
   * @memberof InlineResponse200
   */
  marine?: number;
  /**
   * Active alerts by marine region
   * @type {{ [key: string]: number; }}
   * @memberof InlineResponse200
   */
  regions?: { [key: string]: number };
  /**
   * Active alerts by area (state/territory)
   * @type {{ [key: string]: number; }}
   * @memberof InlineResponse200
   */
  areas?: { [key: string]: number };
  /**
   * Active alerts by NWS public zone or county code
   * @type {{ [key: string]: number; }}
   * @memberof InlineResponse200
   */
  zones?: { [key: string]: number };
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   * A list of recognized event types
   * @type {Array<string>}
   * @memberof InlineResponse2001
   */
  eventTypes?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   *
   * @type {JsonLdContext}
   * @memberof InlineResponse2002
   */
  context?: JsonLdContext;
  /**
   * A list of glossary terms
   * @type {Array<InlineResponse2002Glossary>}
   * @memberof InlineResponse2002
   */
  glossary?: Array<InlineResponse2002Glossary>;
}
/**
 *
 * @export
 * @interface InlineResponse2002Glossary
 */
export interface InlineResponse2002Glossary {
  /**
   * The term being defined
   * @type {string}
   * @memberof InlineResponse2002Glossary
   */
  term?: string;
  /**
   * A definition for the term
   * @type {string}
   * @memberof InlineResponse2002Glossary
   */
  definition?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   *
   * @type {JsonLdContext}
   * @memberof InlineResponse2003
   */
  context?: JsonLdContext;
  /**
   *
   * @type {{ [key: string]: InlineResponse2003Icons; }}
   * @memberof InlineResponse2003
   */
  icons: { [key: string]: InlineResponse2003Icons };
}
/**
 *
 * @export
 * @interface InlineResponse2003Icons
 */
export interface InlineResponse2003Icons {
  /**
   *
   * @type {string}
   * @memberof InlineResponse2003Icons
   */
  description: string;
}
/**
 *
 * @export
 * @interface JsonLdContext
 */
export interface JsonLdContext {}
/**
 * Land region code. These correspond to the six NWS regional headquarters: * AR: Alaska Region * CR: Central Region * ER: Eastern Region * PR: Pacific Region * SR: Southern Region * WR: Western Region
 * @export
 * @enum {string}
 */
export enum LandRegionCode {
  AR = <any>"AR",
  CR = <any>"CR",
  ER = <any>"ER",
  PR = <any>"PR",
  SR = <any>"SR",
  WR = <any>"WR",
}
/**
 * Marine area code as defined in NWS Directive 10-302: * AM: Western North Atlantic Ocean and along U.S. East Coast south of Currituck Beach Light NC following the coastline into Gulf of Mexico to Ocean Reef FL including the Caribbean * AN: Western North Atlantic Ocean and along U.S. East Coast from Canadian border south to Currituck Beach Light NC * GM: Gulf of Mexico and along the U.S. Gulf Coast from the Mexican border to Ocean Reef FL * LC: Lake St. Clair * LE: Lake Erie * LH: Lake Huron * LM: Lake Michigan * LO: Lake Ontario * LS: Lake Superior * PH: Central Pacific Ocean including Hawaiian waters * PK: North Pacific Ocean near Alaska and along Alaska coastline including the Bering Sea and the Gulf of Alaska * PM: Western Pacific Ocean including Mariana Island waters * PS: South Central Pacific Ocean including American Samoa waters * PZ: Eastern North Pacific Ocean and along U.S. West Coast from Canadian border to Mexican border * SL: St. Lawrence River above St. Regis
 * @export
 * @enum {string}
 */
export enum MarineAreaCode {
  AM = <any>"AM",
  AN = <any>"AN",
  GM = <any>"GM",
  LC = <any>"LC",
  LE = <any>"LE",
  LH = <any>"LH",
  LM = <any>"LM",
  LO = <any>"LO",
  LS = <any>"LS",
  PH = <any>"PH",
  PK = <any>"PK",
  PM = <any>"PM",
  PS = <any>"PS",
  PZ = <any>"PZ",
  SL = <any>"SL",
}
/**
 * Marine region code. These are groups of marine areas combined. * AL: Alaska waters (PK) * AT: Atlantic Ocean (AM, AN) * GL: Great Lakes (LC, LE, LH, LM, LO, LS, SL) * GM: Gulf of Mexico (GM) * PA: Eastern Pacific Ocean and U.S. West Coast (PZ) * PI: Central and Western Pacific (PH, PM, PS)
 * @export
 * @enum {string}
 */
export enum MarineRegionCode {
  AL = <any>"AL",
  AT = <any>"AT",
  GL = <any>"GL",
  GM = <any>"GM",
  PA = <any>"PA",
  PI = <any>"PI",
}
/**
 * An object representing a decoded METAR phenomenon string.
 * @export
 * @interface MetarPhenomenon
 */
export interface MetarPhenomenon {
  /**
   *
   * @type {string}
   * @memberof MetarPhenomenon
   */
  intensity: MetarPhenomenon.IntensityEnum;
  /**
   *
   * @type {string}
   * @memberof MetarPhenomenon
   */
  modifier: MetarPhenomenon.ModifierEnum;
  /**
   *
   * @type {string}
   * @memberof MetarPhenomenon
   */
  weather: MetarPhenomenon.WeatherEnum;
  /**
   *
   * @type {string}
   * @memberof MetarPhenomenon
   */
  rawString: string;
  /**
   *
   * @type {boolean}
   * @memberof MetarPhenomenon
   */
  inVicinity?: boolean;
}

/**
 * @export
 * @namespace MetarPhenomenon
 */
export namespace MetarPhenomenon {
  /**
   * @export
   * @enum {string}
   */
  export enum IntensityEnum {
    Light = <any>"light",
    Heavy = <any>"heavy",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum ModifierEnum {
    Patches = <any>"patches",
    Blowing = <any>"blowing",
    LowDrifting = <any>"low_drifting",
    Freezing = <any>"freezing",
    Shallow = <any>"shallow",
    Partial = <any>"partial",
    Showers = <any>"showers",
  }
  /**
   * @export
   * @enum {string}
   */
  export enum WeatherEnum {
    FogMist = <any>"fog_mist",
    DustStorm = <any>"dust_storm",
    Dust = <any>"dust",
    Drizzle = <any>"drizzle",
    FunnelCloud = <any>"funnel_cloud",
    Fog = <any>"fog",
    Smoke = <any>"smoke",
    Hail = <any>"hail",
    SnowPellets = <any>"snow_pellets",
    Haze = <any>"haze",
    IceCrystals = <any>"ice_crystals",
    IcePellets = <any>"ice_pellets",
    DustWhirls = <any>"dust_whirls",
    Spray = <any>"spray",
    Rain = <any>"rain",
    Sand = <any>"sand",
    SnowGrains = <any>"snow_grains",
    Snow = <any>"snow",
    Squalls = <any>"squalls",
    SandStorm = <any>"sand_storm",
    Thunderstorms = <any>"thunderstorms",
    Unknown = <any>"unknown",
    VolcanicAsh = <any>"volcanic_ash",
  }
}
/**
 *
 * @export
 * @enum {string}
 */
export enum MetarSkyCoverage {
  OVC = <any>"OVC",
  BKN = <any>"BKN",
  SCT = <any>"SCT",
  FEW = <any>"FEW",
  SKC = <any>"SKC",
  CLR = <any>"CLR",
  VV = <any>"VV",
}
/**
 * Three-letter identifier for a NWS office.
 * @export
 * @enum {string}
 */
export enum NWSForecastOfficeId {
  AKQ = <any>"AKQ",
  ALY = <any>"ALY",
  BGM = <any>"BGM",
  BOX = <any>"BOX",
  BTV = <any>"BTV",
  BUF = <any>"BUF",
  CAE = <any>"CAE",
  CAR = <any>"CAR",
  CHS = <any>"CHS",
  CLE = <any>"CLE",
  CTP = <any>"CTP",
  GSP = <any>"GSP",
  GYX = <any>"GYX",
  ILM = <any>"ILM",
  ILN = <any>"ILN",
  LWX = <any>"LWX",
  MHX = <any>"MHX",
  OKX = <any>"OKX",
  PBZ = <any>"PBZ",
  PHI = <any>"PHI",
  RAH = <any>"RAH",
  RLX = <any>"RLX",
  RNK = <any>"RNK",
  ABQ = <any>"ABQ",
  AMA = <any>"AMA",
  BMX = <any>"BMX",
  BRO = <any>"BRO",
  CRP = <any>"CRP",
  EPZ = <any>"EPZ",
  EWX = <any>"EWX",
  FFC = <any>"FFC",
  FWD = <any>"FWD",
  HGX = <any>"HGX",
  HUN = <any>"HUN",
  JAN = <any>"JAN",
  JAX = <any>"JAX",
  KEY = <any>"KEY",
  LCH = <any>"LCH",
  LIX = <any>"LIX",
  LUB = <any>"LUB",
  LZK = <any>"LZK",
  MAF = <any>"MAF",
  MEG = <any>"MEG",
  MFL = <any>"MFL",
  MLB = <any>"MLB",
  MOB = <any>"MOB",
  MRX = <any>"MRX",
  OHX = <any>"OHX",
  OUN = <any>"OUN",
  SHV = <any>"SHV",
  SJT = <any>"SJT",
  SJU = <any>"SJU",
  TAE = <any>"TAE",
  TBW = <any>"TBW",
  TSA = <any>"TSA",
  ABR = <any>"ABR",
  APX = <any>"APX",
  ARX = <any>"ARX",
  BIS = <any>"BIS",
  BOU = <any>"BOU",
  CYS = <any>"CYS",
  DDC = <any>"DDC",
  DLH = <any>"DLH",
  DMX = <any>"DMX",
  DTX = <any>"DTX",
  DVN = <any>"DVN",
  EAX = <any>"EAX",
  FGF = <any>"FGF",
  FSD = <any>"FSD",
  GID = <any>"GID",
  GJT = <any>"GJT",
  GLD = <any>"GLD",
  GRB = <any>"GRB",
  GRR = <any>"GRR",
  ICT = <any>"ICT",
  ILX = <any>"ILX",
  IND = <any>"IND",
  IWX = <any>"IWX",
  JKL = <any>"JKL",
  LBF = <any>"LBF",
  LMK = <any>"LMK",
  LOT = <any>"LOT",
  LSX = <any>"LSX",
  MKX = <any>"MKX",
  MPX = <any>"MPX",
  MQT = <any>"MQT",
  OAX = <any>"OAX",
  PAH = <any>"PAH",
  PUB = <any>"PUB",
  RIW = <any>"RIW",
  SGF = <any>"SGF",
  TOP = <any>"TOP",
  UNR = <any>"UNR",
  BOI = <any>"BOI",
  BYZ = <any>"BYZ",
  EKA = <any>"EKA",
  FGZ = <any>"FGZ",
  GGW = <any>"GGW",
  HNX = <any>"HNX",
  LKN = <any>"LKN",
  LOX = <any>"LOX",
  MFR = <any>"MFR",
  MSO = <any>"MSO",
  MTR = <any>"MTR",
  OTX = <any>"OTX",
  PDT = <any>"PDT",
  PIH = <any>"PIH",
  PQR = <any>"PQR",
  PSR = <any>"PSR",
  REV = <any>"REV",
  SEW = <any>"SEW",
  SGX = <any>"SGX",
  SLC = <any>"SLC",
  STO = <any>"STO",
  TFX = <any>"TFX",
  TWC = <any>"TWC",
  VEF = <any>"VEF",
  AER = <any>"AER",
  AFC = <any>"AFC",
  AFG = <any>"AFG",
  AJK = <any>"AJK",
  ALU = <any>"ALU",
  GUM = <any>"GUM",
  HPA = <any>"HPA",
  HFO = <any>"HFO",
  PPG = <any>"PPG",
  STU = <any>"STU",
  NH1 = <any>"NH1",
  NH2 = <any>"NH2",
  ONA = <any>"ONA",
  ONP = <any>"ONP",
}
/**
 * UGC identifier for a NWS forecast zone or county. The first two letters will correspond to either a state code or marine area code (see #/components/schemas/StateTerritoryCode and #/components/schemas/MarineAreaCode for lists of valid letter combinations). The third letter will be Z for public/fire zone or C for county.
 * @export
 */
export type NWSZoneID = string;
/**
 *
 * @export
 * @enum {string}
 */
export enum NWSZoneType {
  Land = <any>"land",
  Marine = <any>"marine",
  Forecast = <any>"forecast",
  Public = <any>"public",
  Coastal = <any>"coastal",
  Offshore = <any>"offshore",
  Fire = <any>"fire",
  County = <any>"county",
}
/**
 *
 * @export
 * @interface Observation
 */
export interface Observation {
  /**
   *
   * @type {JsonLdContext}
   * @memberof Observation
   */
  context?: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof Observation
   */
  geometry?: GeometryString;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  type?: Observation.TypeEnum;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  elevation?: QuantitativeValue;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  station?: string;
  /**
   *
   * @type {Date}
   * @memberof Observation
   */
  timestamp?: Date;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  rawMessage?: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  textDescription?: string;
  /**
   *
   * @type {string}
   * @memberof Observation
   */
  icon?: string;
  /**
   *
   * @type {Array<MetarPhenomenon>}
   * @memberof Observation
   */
  presentWeather?: Array<MetarPhenomenon>;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  temperature?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  dewpoint?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  windDirection?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  windSpeed?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  windGust?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  barometricPressure?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  seaLevelPressure?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  visibility?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  maxTemperatureLast24Hours?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  minTemperatureLast24Hours?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  precipitationLastHour?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  precipitationLast3Hours?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  precipitationLast6Hours?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  relativeHumidity?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  windChill?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof Observation
   */
  heatIndex?: QuantitativeValue;
  /**
   *
   * @type {Array<ObservationCloudLayers>}
   * @memberof Observation
   */
  cloudLayers?: Array<ObservationCloudLayers>;
}

/**
 * @export
 * @namespace Observation
 */
export namespace Observation {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    WxObservationStation = <any>"wx:ObservationStation",
  }
}
/**
 *
 * @export
 * @interface ObservationCloudLayers
 */
export interface ObservationCloudLayers {
  /**
   *
   * @type {QuantitativeValue}
   * @memberof ObservationCloudLayers
   */
  base: QuantitativeValue;
  /**
   *
   * @type {MetarSkyCoverage}
   * @memberof ObservationCloudLayers
   */
  amount: MetarSkyCoverage;
}
/**
 *
 * @export
 * @interface ObservationCollectionGeoJson
 */
export interface ObservationCollectionGeoJson extends GeoJsonFeatureCollection {
  /**
   *
   * @type {Array<ObservationCollectionGeoJsonFeatures>}
   * @memberof ObservationCollectionGeoJson
   */
  features: Array<ObservationCollectionGeoJsonFeatures>;
}

/**
 * @export
 * @namespace ObservationCollectionGeoJson
 */
export namespace ObservationCollectionGeoJson {}
/**
 *
 * @export
 * @interface ObservationCollectionGeoJsonFeatures
 */
export interface ObservationCollectionGeoJsonFeatures extends GeoJsonFeature {
  /**
   *
   * @type {Observation}
   * @memberof ObservationCollectionGeoJsonFeatures
   */
  properties: Observation;
}
/**
 *
 * @export
 * @interface ObservationCollectionJsonLd
 */
export interface ObservationCollectionJsonLd {
  /**
   *
   * @type {JsonLdContext}
   * @memberof ObservationCollectionJsonLd
   */
  context?: JsonLdContext;
  /**
   *
   * @type {Array<Observation>}
   * @memberof ObservationCollectionJsonLd
   */
  graph?: Array<Observation>;
}
/**
 *
 * @export
 * @interface ObservationGeoJson
 */
export interface ObservationGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {Observation}
   * @memberof ObservationGeoJson
   */
  properties: Observation;
}

/**
 * @export
 * @namespace ObservationGeoJson
 */
export namespace ObservationGeoJson {}
/**
 *
 * @export
 * @interface ObservationJsonLd
 */
export interface ObservationJsonLd {}
/**
 *
 * @export
 * @interface ObservationStation
 */
export interface ObservationStation {
  /**
   *
   * @type {JsonLdContext}
   * @memberof ObservationStation
   */
  context?: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof ObservationStation
   */
  geometry?: GeometryString;
  /**
   *
   * @type {string}
   * @memberof ObservationStation
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ObservationStation
   */
  type?: ObservationStation.TypeEnum;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof ObservationStation
   */
  elevation?: QuantitativeValue;
  /**
   *
   * @type {string}
   * @memberof ObservationStation
   */
  stationIdentifier?: string;
  /**
   *
   * @type {string}
   * @memberof ObservationStation
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ObservationStation
   */
  timeZone?: string;
  /**
   * A link to the NWS public forecast zone containing this station.
   * @type {string}
   * @memberof ObservationStation
   */
  forecast?: string;
  /**
   * A link to the NWS county zone containing this station.
   * @type {string}
   * @memberof ObservationStation
   */
  county?: string;
  /**
   * A link to the NWS fire weather forecast zone containing this station.
   * @type {string}
   * @memberof ObservationStation
   */
  fireWeatherZone?: string;
}

/**
 * @export
 * @namespace ObservationStation
 */
export namespace ObservationStation {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    WxObservationStation = <any>"wx:ObservationStation",
  }
}
/**
 *
 * @export
 * @interface ObservationStationCollectionGeoJson
 */
export interface ObservationStationCollectionGeoJson
  extends GeoJsonFeatureCollection {
  /**
   *
   * @type {Array<ObservationStationCollectionGeoJsonFeatures>}
   * @memberof ObservationStationCollectionGeoJson
   */
  features: Array<ObservationStationCollectionGeoJsonFeatures>;
  /**
   *
   * @type {Array<string>}
   * @memberof ObservationStationCollectionGeoJson
   */
  observationStations?: Array<string>;
}

/**
 * @export
 * @namespace ObservationStationCollectionGeoJson
 */
export namespace ObservationStationCollectionGeoJson {}
/**
 *
 * @export
 * @interface ObservationStationCollectionGeoJsonFeatures
 */
export interface ObservationStationCollectionGeoJsonFeatures
  extends GeoJsonFeature {
  /**
   *
   * @type {ObservationStation}
   * @memberof ObservationStationCollectionGeoJsonFeatures
   */
  properties: ObservationStation;
}
/**
 *
 * @export
 * @interface ObservationStationCollectionJsonLd
 */
export interface ObservationStationCollectionJsonLd {
  /**
   *
   * @type {JsonLdContext}
   * @memberof ObservationStationCollectionJsonLd
   */
  context?: JsonLdContext;
  /**
   *
   * @type {Array<ObservationStation>}
   * @memberof ObservationStationCollectionJsonLd
   */
  graph?: Array<ObservationStation>;
  /**
   *
   * @type {Array<string>}
   * @memberof ObservationStationCollectionJsonLd
   */
  observationStations?: Array<string>;
}
/**
 *
 * @export
 * @interface ObservationStationGeoJson
 */
export interface ObservationStationGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {ObservationStation}
   * @memberof ObservationStationGeoJson
   */
  properties: ObservationStation;
}

/**
 * @export
 * @namespace ObservationStationGeoJson
 */
export namespace ObservationStationGeoJson {}
/**
 *
 * @export
 * @interface ObservationStationJsonLd
 */
export interface ObservationStationJsonLd extends ObservationStation {
  /**
   *
   * @type {JsonLdContext}
   * @memberof ObservationStationJsonLd
   */
  context: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof ObservationStationJsonLd
   */
  geometry: GeometryString;
}

/**
 * @export
 * @namespace ObservationStationJsonLd
 */
export namespace ObservationStationJsonLd {}
/**
 *
 * @export
 * @interface Office
 */
export interface Office {
  /**
   *
   * @type {JsonLdContext}
   * @memberof Office
   */
  context?: JsonLdContext;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  type?: Office.TypeEnum;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  "@id"?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  name?: string;
  /**
   *
   * @type {OfficeAddress}
   * @memberof Office
   */
  address?: OfficeAddress;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  telephone?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  faxNumber?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  email?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  sameAs?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  nwsRegion?: string;
  /**
   *
   * @type {string}
   * @memberof Office
   */
  parentOrganization?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Office
   */
  responsibleCounties?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Office
   */
  responsibleForecastZones?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Office
   */
  responsibleFireZones?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Office
   */
  approvedObservationStations?: Array<string>;
}

/**
 * @export
 * @namespace Office
 */
export namespace Office {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    GovernmentOrganization = <any>"GovernmentOrganization",
  }
}
/**
 *
 * @export
 * @interface OfficeAddress
 */
export interface OfficeAddress {
  /**
   *
   * @type {string}
   * @memberof OfficeAddress
   */
  type?: OfficeAddress.TypeEnum;
  /**
   *
   * @type {string}
   * @memberof OfficeAddress
   */
  streetAddress?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeAddress
   */
  addressLocality?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeAddress
   */
  addressRegion?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeAddress
   */
  postalCode?: string;
}

/**
 * @export
 * @namespace OfficeAddress
 */
export namespace OfficeAddress {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    PostalAddress = <any>"PostalAddress",
  }
}
/**
 *
 * @export
 * @interface OfficeHeadline
 */
export interface OfficeHeadline {
  /**
   *
   * @type {JsonLdContext}
   * @memberof OfficeHeadline
   */
  context?: JsonLdContext;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  "@id"?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  office?: string;
  /**
   *
   * @type {boolean}
   * @memberof OfficeHeadline
   */
  important?: boolean;
  /**
   *
   * @type {Date}
   * @memberof OfficeHeadline
   */
  issuanceTime?: Date;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  link?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  title?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  summary?: string;
  /**
   *
   * @type {string}
   * @memberof OfficeHeadline
   */
  content?: string;
}
/**
 *
 * @export
 * @interface OfficeHeadlineCollection
 */
export interface OfficeHeadlineCollection {
  /**
   *
   * @type {JsonLdContext}
   * @memberof OfficeHeadlineCollection
   */
  context: JsonLdContext;
  /**
   *
   * @type {Array<OfficeHeadline>}
   * @memberof OfficeHeadlineCollection
   */
  graph: Array<OfficeHeadline>;
}
/**
 *
 * @export
 * @interface Point
 */
export interface Point {
  /**
   *
   * @type {JsonLdContext}
   * @memberof Point
   */
  context?: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof Point
   */
  geometry?: GeometryString;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  type?: Point.TypeEnum;
  /**
   *
   * @type {NWSForecastOfficeId}
   * @memberof Point
   */
  cwa?: NWSForecastOfficeId;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  forecastOffice?: string;
  /**
   *
   * @type {NWSForecastOfficeId}
   * @memberof Point
   */
  gridId?: NWSForecastOfficeId;
  /**
   *
   * @type {number}
   * @memberof Point
   */
  gridX?: number;
  /**
   *
   * @type {number}
   * @memberof Point
   */
  gridY?: number;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  forecast?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  forecastHourly?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  forecastGridData?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  observationStations?: string;
  /**
   *
   * @type {RelativeLocationGeoJson | RelativeLocationJsonLd}
   * @memberof Point
   */
  relativeLocation?: RelativeLocationGeoJson | RelativeLocationJsonLd;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  forecastZone?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  county?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  fireWeatherZone?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  timeZone?: string;
  /**
   *
   * @type {string}
   * @memberof Point
   */
  radarStation?: string;
}

/**
 * @export
 * @namespace Point
 */
export namespace Point {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    WxPoint = <any>"wx:Point",
  }
}
/**
 *
 * @export
 * @interface PointGeoJson
 */
export interface PointGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {Point}
   * @memberof PointGeoJson
   */
  properties: Point;
}

/**
 * @export
 * @namespace PointGeoJson
 */
export namespace PointGeoJson {}
/**
 *
 * @export
 * @interface PointJsonLd
 */
export interface PointJsonLd extends Point {
  /**
   *
   * @type {JsonLdContext}
   * @memberof PointJsonLd
   */
  context: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof PointJsonLd
   */
  geometry: GeometryString;
}

/**
 * @export
 * @namespace PointJsonLd
 */
export namespace PointJsonLd {}
/**
 *
 * @export
 */
export type PointString = string;
/**
 * Detail about an error. This document conforms to RFC 7807 (Problem Details for HTTP APIs).
 * @export
 * @interface ProblemDetail
 */
export interface ProblemDetail {
  type: string;
  title: string;
  status: number;
  detail: string;
  instance: string;
  correlationId: string;
}
/**
 * A structured value representing a measurement and its unit of measure. This object is a slighly modified version of the schema.org definition at https://schema.org/QuantitativeValue
 * @export
 * @interface QuantitativeValue
 */
export interface QuantitativeValue {
  /**
   * A measured value
   * @type {number}
   * @memberof QuantitativeValue
   */
  value?: number;
  /**
   * The maximum value of a range of measured values
   * @type {number}
   * @memberof QuantitativeValue
   */
  maxValue?: number;
  /**
   * The minimum value of a range of measured values
   * @type {number}
   * @memberof QuantitativeValue
   */
  minValue?: number;
  /**
   *
   * @type {UnitOfMeasure}
   * @memberof QuantitativeValue
   */
  unitCode?: UnitOfMeasure;
  /**
   * For values in observation records, the quality control flag from the MADIS system. The definitions of these flags can be found at https://madis.ncep.noaa.gov/madis_sfc_qc_notes.shtml
   * @type {string}
   * @memberof QuantitativeValue
   */
  qualityControl?: QuantitativeValue.QualityControlEnum;
}

/**
 * @export
 * @namespace QuantitativeValue
 */
export namespace QuantitativeValue {
  /**
   * @export
   * @enum {string}
   */
  export enum QualityControlEnum {
    Z = <any>"Z",
    C = <any>"C",
    S = <any>"S",
    V = <any>"V",
    X = <any>"X",
    Q = <any>"Q",
    G = <any>"G",
    B = <any>"B",
    T = <any>"T",
  }
}
/**
 *
 * @export
 * @interface RegionCode
 */
export interface RegionCode {}
/**
 *
 * @export
 * @interface RelativeLocation
 */
export interface RelativeLocation {
  /**
   *
   * @type {string}
   * @memberof RelativeLocation
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof RelativeLocation
   */
  state?: string;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof RelativeLocation
   */
  distance?: QuantitativeValue;
  /**
   *
   * @type {QuantitativeValue}
   * @memberof RelativeLocation
   */
  bearing?: QuantitativeValue;
}
/**
 *
 * @export
 * @interface RelativeLocationGeoJson
 */
export interface RelativeLocationGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {RelativeLocation}
   * @memberof RelativeLocationGeoJson
   */
  properties: RelativeLocation;
}

/**
 * @export
 * @namespace RelativeLocationGeoJson
 */
export namespace RelativeLocationGeoJson {}
/**
 *
 * @export
 * @interface RelativeLocationJsonLd
 */
export interface RelativeLocationJsonLd extends RelativeLocation {
  /**
   *
   * @type {GeometryString}
   * @memberof RelativeLocationJsonLd
   */
  geometry: GeometryString;
}
/**
 *
 * @export
 * @interface Size
 */
export interface Size {}
/**
 *
 * @export
 * @interface Size1
 */
export interface Size1 {}
/**
 *
 * @export
 * @enum {string}
 */
export enum StateTerritoryCode {
  AL = <any>"AL",
  AK = <any>"AK",
  AS = <any>"AS",
  AR = <any>"AR",
  AZ = <any>"AZ",
  CA = <any>"CA",
  CO = <any>"CO",
  CT = <any>"CT",
  DE = <any>"DE",
  DC = <any>"DC",
  FL = <any>"FL",
  GA = <any>"GA",
  GU = <any>"GU",
  HI = <any>"HI",
  ID = <any>"ID",
  IL = <any>"IL",
  IN = <any>"IN",
  IA = <any>"IA",
  KS = <any>"KS",
  KY = <any>"KY",
  LA = <any>"LA",
  ME = <any>"ME",
  MD = <any>"MD",
  MA = <any>"MA",
  MI = <any>"MI",
  MN = <any>"MN",
  MS = <any>"MS",
  MO = <any>"MO",
  MT = <any>"MT",
  NE = <any>"NE",
  NV = <any>"NV",
  NH = <any>"NH",
  NJ = <any>"NJ",
  NM = <any>"NM",
  NY = <any>"NY",
  NC = <any>"NC",
  ND = <any>"ND",
  OH = <any>"OH",
  OK = <any>"OK",
  OR = <any>"OR",
  PA = <any>"PA",
  PR = <any>"PR",
  RI = <any>"RI",
  SC = <any>"SC",
  SD = <any>"SD",
  TN = <any>"TN",
  TX = <any>"TX",
  UT = <any>"UT",
  VT = <any>"VT",
  VI = <any>"VI",
  VA = <any>"VA",
  WA = <any>"WA",
  WV = <any>"WV",
  WI = <any>"WI",
  WY = <any>"WY",
  MP = <any>"MP",
  PW = <any>"PW",
  FM = <any>"FM",
  MH = <any>"MH",
}
/**
 *
 * @export
 * @interface TextProduct
 */
export interface TextProduct {
  /**
   *
   * @type {JsonLdContext}
   * @memberof TextProduct
   */
  context?: JsonLdContext;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  "@id"?: string;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  wmoCollectiveId?: string;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  issuingOffice?: string;
  /**
   *
   * @type {Date}
   * @memberof TextProduct
   */
  issuanceTime?: Date;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  productCode?: string;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  productName?: string;
  /**
   *
   * @type {string}
   * @memberof TextProduct
   */
  productText?: string;
}
/**
 *
 * @export
 * @interface TextProductCollection
 */
export interface TextProductCollection {
  /**
   *
   * @type {JsonLdContext}
   * @memberof TextProductCollection
   */
  context?: JsonLdContext;
  /**
   *
   * @type {Array<TextProduct>}
   * @memberof TextProductCollection
   */
  graph?: Array<TextProduct>;
}
/**
 *
 * @export
 * @interface TextProductLocationCollection
 */
export interface TextProductLocationCollection {
  /**
   *
   * @type {JsonLdContext}
   * @memberof TextProductLocationCollection
   */
  context?: JsonLdContext;
  /**
   *
   * @type {{ [key: string]: string; }}
   * @memberof TextProductLocationCollection
   */
  locations?: { [key: string]: string };
}
/**
 *
 * @export
 * @interface TextProductTypeCollection
 */
export interface TextProductTypeCollection {
  /**
   *
   * @type {JsonLdContext}
   * @memberof TextProductTypeCollection
   */
  context?: JsonLdContext;
  /**
   *
   * @type {Array<TextProductTypeCollectionGraph>}
   * @memberof TextProductTypeCollection
   */
  graph?: Array<TextProductTypeCollectionGraph>;
}
/**
 *
 * @export
 * @interface TextProductTypeCollectionGraph
 */
export interface TextProductTypeCollectionGraph {
  /**
   *
   * @type {string}
   * @memberof TextProductTypeCollectionGraph
   */
  productCode: string;
  /**
   *
   * @type {string}
   * @memberof TextProductTypeCollectionGraph
   */
  productName: string;
}
/**
 * A string denoting a unit of measure, expressed in the format \"{unit}\" or \"{namespace}:{unit}\". Units with the namespace \"wmo\" or \"wmoUnit\" are defined in the World Meteorological Organization Codes Registry at http://codes.wmo.int/common/unit and should be canonically resolvable to http://codes.wmo.int/common/unit/{unit}. Units with the namespace \"nwsUnit\" are currently custom and do not align to any standard. Units with no namespace or the namespace \"uc\" are compliant with the Unified Code for Units of Measure syntax defined at https://unitsofmeasure.org/. This also aligns with recent versions of the Geographic Markup Language (GML) standard, the IWXXM standard, and OGC Observations and Measurements v2.0 (ISO/DIS 19156). Namespaced units are considered deprecated. We will be aligning API to use the same standards as GML/IWXXM in the future.
 * @export
 */
export type UnitOfMeasure = string;
/**
 *
 * @export
 * @interface Zone
 */
export interface Zone {
  /**
   *
   * @type {JsonLdContext}
   * @memberof Zone
   */
  context?: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof Zone
   */
  geometry?: GeometryString;
  /**
   *
   * @type {string}
   * @memberof Zone
   */
  "@id"?: string;
  /**
   *
   * @type {string}
   * @memberof Zone
   */
  "@type"?: Zone.TypeEnum;
  /**
   *
   * @type {NWSZoneID}
   * @memberof Zone
   */
  id?: NWSZoneID;
  /**
   *
   * @type {NWSZoneType}
   * @memberof Zone
   */
  type?: NWSZoneType;
  /**
   *
   * @type {string}
   * @memberof Zone
   */
  name?: string;
  /**
   *
   * @type {Date}
   * @memberof Zone
   */
  effectiveDate?: Date;
  /**
   *
   * @type {Date}
   * @memberof Zone
   */
  expirationDate?: Date;
  /**
   *
   * @type {StateTerritoryCode | string}
   * @memberof Zone
   */
  state?: StateTerritoryCode | string;
  /**
   *
   * @type {Array<NWSForecastOfficeId>}
   * @memberof Zone
   */
  cwa?: Array<NWSForecastOfficeId>;
  /**
   *
   * @type {Array<string>}
   * @memberof Zone
   */
  forecastOffices?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Zone
   */
  timeZone?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof Zone
   */
  observationStations?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Zone
   */
  radarStation?: string;
}

/**
 * @export
 * @namespace Zone
 */
export namespace Zone {
  /**
   * @export
   * @enum {string}
   */
  export enum TypeEnum {
    WxZone = <any>"wx:Zone",
  }
}
/**
 *
 * @export
 * @interface ZoneCollectionGeoJson
 */
export interface ZoneCollectionGeoJson extends GeoJsonFeatureCollection {
  /**
   *
   * @type {Array<ZoneCollectionGeoJsonFeatures>}
   * @memberof ZoneCollectionGeoJson
   */
  features: Array<ZoneCollectionGeoJsonFeatures>;
}

/**
 * @export
 * @namespace ZoneCollectionGeoJson
 */
export namespace ZoneCollectionGeoJson {}
/**
 *
 * @export
 * @interface ZoneCollectionGeoJsonFeatures
 */
export interface ZoneCollectionGeoJsonFeatures extends GeoJsonFeature {
  /**
   *
   * @type {Zone}
   * @memberof ZoneCollectionGeoJsonFeatures
   */
  properties: Zone;
}
/**
 *
 * @export
 * @interface ZoneCollectionJsonLd
 */
export interface ZoneCollectionJsonLd {
  /**
   *
   * @type {JsonLdContext}
   * @memberof ZoneCollectionJsonLd
   */
  context?: JsonLdContext;
  /**
   *
   * @type {Array<Zone>}
   * @memberof ZoneCollectionJsonLd
   */
  graph?: Array<Zone>;
}
/**
 * An object representing a zone area forecast.
 * @export
 * @interface ZoneForecast
 */
export interface ZoneForecast {
  /**
   *
   * @type {JsonLdContext}
   * @memberof ZoneForecast
   */
  context?: JsonLdContext;
  /**
   *
   * @type {GeometryString}
   * @memberof ZoneForecast
   */
  geometry?: GeometryString;
  /**
   * An API link to the zone this forecast is for.
   * @type {string}
   * @memberof ZoneForecast
   */
  zone?: string;
  /**
   * The time this zone forecast product was published.
   * @type {Date}
   * @memberof ZoneForecast
   */
  updated?: Date;
  /**
   * An array of forecast periods.
   * @type {Array<ZoneForecastPeriods>}
   * @memberof ZoneForecast
   */
  periods?: Array<ZoneForecastPeriods>;
}
/**
 *
 * @export
 * @interface ZoneForecastGeoJson
 */
export interface ZoneForecastGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {ZoneForecast}
   * @memberof ZoneForecastGeoJson
   */
  properties: ZoneForecast;
}

/**
 * @export
 * @namespace ZoneForecastGeoJson
 */
export namespace ZoneForecastGeoJson {}
/**
 *
 * @export
 * @interface ZoneForecastJsonLd
 */
export interface ZoneForecastJsonLd {}
/**
 *
 * @export
 * @interface ZoneForecastPeriods
 */
export interface ZoneForecastPeriods {
  /**
   * A sequential identifier number.
   * @type {number}
   * @memberof ZoneForecastPeriods
   */
  number: number;
  /**
   * A textual description of the period.
   * @type {string}
   * @memberof ZoneForecastPeriods
   */
  name: string;
  /**
   * A detailed textual forecast for the period.
   * @type {string}
   * @memberof ZoneForecastPeriods
   */
  detailedForecast: string;
}
/**
 *
 * @export
 * @interface ZoneGeoJson
 */
export interface ZoneGeoJson extends GeoJsonFeature {
  /**
   *
   * @type {Zone}
   * @memberof ZoneGeoJson
   */
  properties: Zone;
}

/**
 * @export
 * @namespace ZoneGeoJson
 */
export namespace ZoneGeoJson {}
/**
 *
 * @export
 * @interface ZoneJsonLd
 */
export interface ZoneJsonLd {}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns all currently active alerts
     * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
     * @param {Array<string>} [messageType] Message type (alert, update, cancel)
     * @param {Array<string>} [event] Event name
     * @param {Array<string>} [code] Event code
     * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
     * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
     * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
     * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
     * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
     * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
     * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
     * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActive(
      status?: Array<string>,
      messageType?: Array<string>,
      event?: Array<string>,
      code?: Array<string>,
      area?: Array<AreaCode>,
      point?: PointString,
      region?: Array<MarineRegionCode>,
      regionType?: string,
      zone?: Array<NWSZoneID>,
      urgency?: Array<AlertUrgency>,
      severity?: Array<AlertSeverity>,
      certainty?: Array<AlertCertainty>,
      limit?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/alerts/active`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (status) {
        localVarQueryParameter["status"] = status.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (messageType) {
        localVarQueryParameter["message_type"] = messageType.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (event) {
        localVarQueryParameter["event"] = event.join(COLLECTION_FORMATS["csv"]);
      }

      if (code) {
        localVarQueryParameter["code"] = code.join(COLLECTION_FORMATS["csv"]);
      }

      if (area) {
        localVarQueryParameter["area"] = area.join(COLLECTION_FORMATS["csv"]);
      }

      if (point !== undefined) {
        localVarQueryParameter["point"] = point;
      }

      if (region) {
        localVarQueryParameter["region"] = region.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (regionType !== undefined) {
        localVarQueryParameter["region_type"] = regionType;
      }

      if (zone) {
        localVarQueryParameter["zone"] = zone.join(COLLECTION_FORMATS["csv"]);
      }

      if (urgency) {
        localVarQueryParameter["urgency"] = urgency.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (severity) {
        localVarQueryParameter["severity"] = severity.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (certainty) {
        localVarQueryParameter["certainty"] = certainty.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns active alerts for the given area (state or marine area)
     * @param {AreaCode} area State/area ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveArea(area: AreaCode, options: any = {}): FetchArgs {
      // verify required parameter 'area' is not null or undefined
      if (area === null || area === undefined) {
        throw new RequiredError(
          "area",
          "Required parameter area was null or undefined when calling alertsActiveArea."
        );
      }
      const localVarPath = `/alerts/active/area/{area}`.replace(
        `{${"area"}}`,
        encodeURIComponent(String(area))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns info on the number of active alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveCount(options: any = {}): FetchArgs {
      const localVarPath = `/alerts/active/count`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns active alerts for the given marine region
     * @param {MarineRegionCode} region Marine region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveRegion(region: MarineRegionCode, options: any = {}): FetchArgs {
      // verify required parameter 'region' is not null or undefined
      if (region === null || region === undefined) {
        throw new RequiredError(
          "region",
          "Required parameter region was null or undefined when calling alertsActiveRegion."
        );
      }
      const localVarPath = `/alerts/active/region/{region}`.replace(
        `{${"region"}}`,
        encodeURIComponent(String(region))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns active alerts for the given NWS public zone or county
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveZone(zoneId: NWSZoneID, options: any = {}): FetchArgs {
      // verify required parameter 'zoneId' is not null or undefined
      if (zoneId === null || zoneId === undefined) {
        throw new RequiredError(
          "zoneId",
          "Required parameter zoneId was null or undefined when calling alertsActiveZone."
        );
      }
      const localVarPath = `/alerts/active/zone/{zoneId}`.replace(
        `{${"zoneId"}}`,
        encodeURIComponent(String(zoneId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns all alerts
     * @param {boolean} [active] List only active alerts (use /alerts/active endpoints instead)
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
     * @param {Array<string>} [messageType] Message type (alert, update, cancel)
     * @param {Array<string>} [event] Event name
     * @param {Array<string>} [code] Event code
     * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
     * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
     * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
     * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
     * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
     * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
     * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
     * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
     * @param {number} [limit] Limit
     * @param {string} [cursor] Pagination cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsQuery(
      active?: boolean,
      start?: Date,
      end?: Date,
      status?: Array<string>,
      messageType?: Array<string>,
      event?: Array<string>,
      code?: Array<string>,
      area?: Array<AreaCode>,
      point?: PointString,
      region?: Array<MarineRegionCode>,
      regionType?: string,
      zone?: Array<NWSZoneID>,
      urgency?: Array<AlertUrgency>,
      severity?: Array<AlertSeverity>,
      certainty?: Array<AlertCertainty>,
      limit?: number,
      cursor?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/alerts`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (active !== undefined) {
        localVarQueryParameter["active"] = active;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = (start as any).toISOString();
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = (end as any).toISOString();
      }

      if (status) {
        localVarQueryParameter["status"] = status.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (messageType) {
        localVarQueryParameter["message_type"] = messageType.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (event) {
        localVarQueryParameter["event"] = event.join(COLLECTION_FORMATS["csv"]);
      }

      if (code) {
        localVarQueryParameter["code"] = code.join(COLLECTION_FORMATS["csv"]);
      }

      if (area) {
        localVarQueryParameter["area"] = area.join(COLLECTION_FORMATS["csv"]);
      }

      if (point !== undefined) {
        localVarQueryParameter["point"] = point;
      }

      if (region) {
        localVarQueryParameter["region"] = region.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (regionType !== undefined) {
        localVarQueryParameter["region_type"] = regionType;
      }

      if (zone) {
        localVarQueryParameter["zone"] = zone.join(COLLECTION_FORMATS["csv"]);
      }

      if (urgency) {
        localVarQueryParameter["urgency"] = urgency.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (severity) {
        localVarQueryParameter["severity"] = severity.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (certainty) {
        localVarQueryParameter["certainty"] = certainty.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (cursor !== undefined) {
        localVarQueryParameter["cursor"] = cursor;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a specific alert
     * @param {AlertId} id Alert identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsSingle(id: AlertId, options: any = {}): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling alertsSingle."
        );
      }
      const localVarPath = `/alerts/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of alert types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsTypes(options: any = {}): FetchArgs {
      const localVarPath = `/alerts/types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns glossary terms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    glossary(options: any = {}): FetchArgs {
      const localVarPath = `/glossary`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns raw numerical forecast data for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpoint(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'wfo' is not null or undefined
      if (wfo === null || wfo === undefined) {
        throw new RequiredError(
          "wfo",
          "Required parameter wfo was null or undefined when calling gridpoint."
        );
      }
      // verify required parameter 'x' is not null or undefined
      if (x === null || x === undefined) {
        throw new RequiredError(
          "x",
          "Required parameter x was null or undefined when calling gridpoint."
        );
      }
      // verify required parameter 'y' is not null or undefined
      if (y === null || y === undefined) {
        throw new RequiredError(
          "y",
          "Required parameter y was null or undefined when calling gridpoint."
        );
      }
      const localVarPath = `/gridpoints/{wfo}/{x},{y}`
        .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
        .replace(`{${"x"}}`, encodeURIComponent(String(x)))
        .replace(`{${"y"}}`, encodeURIComponent(String(y)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a textual forecast for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
     * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointForecast(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      featureFlags?: Array<string>,
      units?: GridpointForecastUnits,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'wfo' is not null or undefined
      if (wfo === null || wfo === undefined) {
        throw new RequiredError(
          "wfo",
          "Required parameter wfo was null or undefined when calling gridpointForecast."
        );
      }
      // verify required parameter 'x' is not null or undefined
      if (x === null || x === undefined) {
        throw new RequiredError(
          "x",
          "Required parameter x was null or undefined when calling gridpointForecast."
        );
      }
      // verify required parameter 'y' is not null or undefined
      if (y === null || y === undefined) {
        throw new RequiredError(
          "y",
          "Required parameter y was null or undefined when calling gridpointForecast."
        );
      }
      const localVarPath = `/gridpoints/{wfo}/{x},{y}/forecast`
        .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
        .replace(`{${"x"}}`, encodeURIComponent(String(x)))
        .replace(`{${"y"}}`, encodeURIComponent(String(y)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (units !== undefined) {
        localVarQueryParameter["units"] = units;
      }

      if (featureFlags) {
        localVarHeaderParameter["Feature-Flags"] = featureFlags.join(
          COLLECTION_FORMATS[""]
        );
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a textual hourly forecast for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
     * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointForecastHourly(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      featureFlags?: Array<string>,
      units?: GridpointForecastUnits,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'wfo' is not null or undefined
      if (wfo === null || wfo === undefined) {
        throw new RequiredError(
          "wfo",
          "Required parameter wfo was null or undefined when calling gridpointForecastHourly."
        );
      }
      // verify required parameter 'x' is not null or undefined
      if (x === null || x === undefined) {
        throw new RequiredError(
          "x",
          "Required parameter x was null or undefined when calling gridpointForecastHourly."
        );
      }
      // verify required parameter 'y' is not null or undefined
      if (y === null || y === undefined) {
        throw new RequiredError(
          "y",
          "Required parameter y was null or undefined when calling gridpointForecastHourly."
        );
      }
      const localVarPath = `/gridpoints/{wfo}/{x},{y}/forecast/hourly`
        .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
        .replace(`{${"x"}}`, encodeURIComponent(String(x)))
        .replace(`{${"y"}}`, encodeURIComponent(String(y)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (units !== undefined) {
        localVarQueryParameter["units"] = units;
      }

      if (featureFlags) {
        localVarHeaderParameter["Feature-Flags"] = featureFlags.join(
          COLLECTION_FORMATS[""]
        );
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of observation stations usable for a given 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointStations(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'wfo' is not null or undefined
      if (wfo === null || wfo === undefined) {
        throw new RequiredError(
          "wfo",
          "Required parameter wfo was null or undefined when calling gridpointStations."
        );
      }
      // verify required parameter 'x' is not null or undefined
      if (x === null || x === undefined) {
        throw new RequiredError(
          "x",
          "Required parameter x was null or undefined when calling gridpointStations."
        );
      }
      // verify required parameter 'y' is not null or undefined
      if (y === null || y === undefined) {
        throw new RequiredError(
          "y",
          "Required parameter y was null or undefined when calling gridpointStations."
        );
      }
      const localVarPath = `/gridpoints/{wfo}/{x},{y}/stations`
        .replace(`{${"wfo"}}`, encodeURIComponent(String(wfo)))
        .replace(`{${"x"}}`, encodeURIComponent(String(x)))
        .replace(`{${"y"}}`, encodeURIComponent(String(y)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {string} set .
     * @param {string} timeOfDay .
     * @param {string} first .
     * @param {Size} [size] Font size
     * @param {number} [fontsize] Font size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    icons(
      set: string,
      timeOfDay: string,
      first: string,
      size?: Size,
      fontsize?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'set' is not null or undefined
      if (set === null || set === undefined) {
        throw new RequiredError(
          "set",
          "Required parameter set was null or undefined when calling icons."
        );
      }
      // verify required parameter 'timeOfDay' is not null or undefined
      if (timeOfDay === null || timeOfDay === undefined) {
        throw new RequiredError(
          "timeOfDay",
          "Required parameter timeOfDay was null or undefined when calling icons."
        );
      }
      // verify required parameter 'first' is not null or undefined
      if (first === null || first === undefined) {
        throw new RequiredError(
          "first",
          "Required parameter first was null or undefined when calling icons."
        );
      }
      const localVarPath = `/icons/{set}/{timeOfDay}/{first}`
        .replace(`{${"set"}}`, encodeURIComponent(String(set)))
        .replace(`{${"timeOfDay"}}`, encodeURIComponent(String(timeOfDay)))
        .replace(`{${"first"}}`, encodeURIComponent(String(first)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (fontsize !== undefined) {
        localVarQueryParameter["fontsize"] = fontsize;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {string} set .
     * @param {string} timeOfDay .
     * @param {string} first .
     * @param {string} second .
     * @param {Size1} [size] Font size
     * @param {number} [fontsize] Font size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iconsDualCondition(
      set: string,
      timeOfDay: string,
      first: string,
      second: string,
      size?: Size1,
      fontsize?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'set' is not null or undefined
      if (set === null || set === undefined) {
        throw new RequiredError(
          "set",
          "Required parameter set was null or undefined when calling iconsDualCondition."
        );
      }
      // verify required parameter 'timeOfDay' is not null or undefined
      if (timeOfDay === null || timeOfDay === undefined) {
        throw new RequiredError(
          "timeOfDay",
          "Required parameter timeOfDay was null or undefined when calling iconsDualCondition."
        );
      }
      // verify required parameter 'first' is not null or undefined
      if (first === null || first === undefined) {
        throw new RequiredError(
          "first",
          "Required parameter first was null or undefined when calling iconsDualCondition."
        );
      }
      // verify required parameter 'second' is not null or undefined
      if (second === null || second === undefined) {
        throw new RequiredError(
          "second",
          "Required parameter second was null or undefined when calling iconsDualCondition."
        );
      }
      const localVarPath = `/icons/{set}/{timeOfDay}/{first}/{second}`
        .replace(`{${"set"}}`, encodeURIComponent(String(set)))
        .replace(`{${"timeOfDay"}}`, encodeURIComponent(String(timeOfDay)))
        .replace(`{${"first"}}`, encodeURIComponent(String(first)))
        .replace(`{${"second"}}`, encodeURIComponent(String(second)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (size !== undefined) {
        localVarQueryParameter["size"] = size;
      }

      if (fontsize !== undefined) {
        localVarQueryParameter["fontsize"] = fontsize;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iconsSummary(options: any = {}): FetchArgs {
      const localVarPath = `/icons`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of valid text product types for a given issuance location
     * @param {string} locationId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locationProducts(locationId: string, options: any = {}): FetchArgs {
      // verify required parameter 'locationId' is not null or undefined
      if (locationId === null || locationId === undefined) {
        throw new RequiredError(
          "locationId",
          "Required parameter locationId was null or undefined when calling locationProducts."
        );
      }
      const localVarPath = `/products/locations/{locationId}/types`.replace(
        `{${"locationId"}}`,
        encodeURIComponent(String(locationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given observation station
     * @param {string} stationId Observation station ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obsStation(stationId: string, options: any = {}): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling obsStation."
        );
      }
      const localVarPath = `/stations/{stationId}`.replace(
        `{${"stationId"}}`,
        encodeURIComponent(String(stationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of observation stations.
     * @param {Array<string>} [id] Filter by observation station ID
     * @param {Array<AreaCode>} [state] Filter by state/marine area code
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obsStations(
      id?: Array<string>,
      state?: Array<AreaCode>,
      limit?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/stations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (id) {
        localVarQueryParameter["id"] = id.join(COLLECTION_FORMATS["csv"]);
      }

      if (state) {
        localVarQueryParameter["state"] = state.join(COLLECTION_FORMATS["csv"]);
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a NWS forecast office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    office(officeId: NWSForecastOfficeId, options: any = {}): FetchArgs {
      // verify required parameter 'officeId' is not null or undefined
      if (officeId === null || officeId === undefined) {
        throw new RequiredError(
          "officeId",
          "Required parameter officeId was null or undefined when calling office."
        );
      }
      const localVarPath = `/offices/{officeId}`.replace(
        `{${"officeId"}}`,
        encodeURIComponent(String(officeId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a specific news headline for a given NWS office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {string} headlineId Headline record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    officeHeadline(
      officeId: NWSForecastOfficeId,
      headlineId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'officeId' is not null or undefined
      if (officeId === null || officeId === undefined) {
        throw new RequiredError(
          "officeId",
          "Required parameter officeId was null or undefined when calling officeHeadline."
        );
      }
      // verify required parameter 'headlineId' is not null or undefined
      if (headlineId === null || headlineId === undefined) {
        throw new RequiredError(
          "headlineId",
          "Required parameter headlineId was null or undefined when calling officeHeadline."
        );
      }
      const localVarPath = `/offices/{officeId}/headlines/{headlineId}`
        .replace(`{${"officeId"}}`, encodeURIComponent(String(officeId)))
        .replace(`{${"headlineId"}}`, encodeURIComponent(String(headlineId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of news headlines for a given NWS office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    officeHeadlines(
      officeId: NWSForecastOfficeId,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'officeId' is not null or undefined
      if (officeId === null || officeId === undefined) {
        throw new RequiredError(
          "officeId",
          "Required parameter officeId was null or undefined when calling officeHeadlines."
        );
      }
      const localVarPath = `/offices/{officeId}/headlines`.replace(
        `{${"officeId"}}`,
        encodeURIComponent(String(officeId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given latitude/longitude point
     * @param {PointString} point Point (latitude, longitude)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    point(point: PointString, options: any = {}): FetchArgs {
      // verify required parameter 'point' is not null or undefined
      if (point === null || point === undefined) {
        throw new RequiredError(
          "point",
          "Required parameter point was null or undefined when calling point."
        );
      }
      const localVarPath = `/points/{point}`.replace(
        `{${"point"}}`,
        encodeURIComponent(String(point))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of observation stations for a given point
     * @param {PointString} point Point (latitude, longitude)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pointStations(point: PointString, options: any = {}): FetchArgs {
      // verify required parameter 'point' is not null or undefined
      if (point === null || point === undefined) {
        throw new RequiredError(
          "point",
          "Required parameter point was null or undefined when calling pointStations."
        );
      }
      const localVarPath = `/points/{point}/stations`.replace(
        `{${"point"}}`,
        encodeURIComponent(String(point))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a specific text product
     * @param {string} productId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    product(productId: string, options: any = {}): FetchArgs {
      // verify required parameter 'productId' is not null or undefined
      if (productId === null || productId === undefined) {
        throw new RequiredError(
          "productId",
          "Required parameter productId was null or undefined when calling product."
        );
      }
      const localVarPath = `/products/{productId}`.replace(
        `{${"productId"}}`,
        encodeURIComponent(String(productId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of valid text product issuance locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productLocations(options: any = {}): FetchArgs {
      const localVarPath = `/products/locations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of valid text product types and codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productTypes(options: any = {}): FetchArgs {
      const localVarPath = `/products/types`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of text products
     * @param {Array<string>} [location] Location id
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {Array<string>} [office] Issuing office
     * @param {Array<string>} [wmoid] WMO id code
     * @param {Array<string>} [type] Product code
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsQuery(
      location?: Array<string>,
      start?: Date,
      end?: Date,
      office?: Array<string>,
      wmoid?: Array<string>,
      type?: Array<string>,
      limit?: number,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/products`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (location) {
        localVarQueryParameter["location"] = location.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = (start as any).toISOString();
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = (end as any).toISOString();
      }

      if (office) {
        localVarQueryParameter["office"] = office.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (wmoid) {
        localVarQueryParameter["wmoid"] = wmoid.join(COLLECTION_FORMATS["csv"]);
      }

      if (type) {
        localVarQueryParameter["type"] = type.join(COLLECTION_FORMATS["csv"]);
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of text products of a given type
     * @param {string} typeId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsType(typeId: string, options: any = {}): FetchArgs {
      // verify required parameter 'typeId' is not null or undefined
      if (typeId === null || typeId === undefined) {
        throw new RequiredError(
          "typeId",
          "Required parameter typeId was null or undefined when calling productsType."
        );
      }
      const localVarPath = `/products/types/{typeId}`.replace(
        `{${"typeId"}}`,
        encodeURIComponent(String(typeId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of text products of a given type for a given issuance location
     * @param {string} typeId .
     * @param {string} locationId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsTypeLocation(
      typeId: string,
      locationId: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'typeId' is not null or undefined
      if (typeId === null || typeId === undefined) {
        throw new RequiredError(
          "typeId",
          "Required parameter typeId was null or undefined when calling productsTypeLocation."
        );
      }
      // verify required parameter 'locationId' is not null or undefined
      if (locationId === null || locationId === undefined) {
        throw new RequiredError(
          "locationId",
          "Required parameter locationId was null or undefined when calling productsTypeLocation."
        );
      }
      const localVarPath = `/products/types/{typeId}/locations/{locationId}`
        .replace(`{${"typeId"}}`, encodeURIComponent(String(typeId)))
        .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of valid text product issuance locations for a given product type
     * @param {string} typeId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsTypeLocations(typeId: string, options: any = {}): FetchArgs {
      // verify required parameter 'typeId' is not null or undefined
      if (typeId === null || typeId === undefined) {
        throw new RequiredError(
          "typeId",
          "Required parameter typeId was null or undefined when calling productsTypeLocations."
        );
      }
      const localVarPath = `/products/types/{typeId}/locations`.replace(
        `{${"typeId"}}`,
        encodeURIComponent(String(typeId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given radar wind profiler
     * @param {string} stationId Profiler station ID
     * @param {ISO8601Interval} [time] Time interval
     * @param {ISO8601Duration} [interval] Averaging interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarProfiler(
      stationId: string,
      time?: ISO8601Interval,
      interval?: ISO8601Duration,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling radarProfiler."
        );
      }
      const localVarPath = `/radar/profilers/{stationId}`.replace(
        `{${"stationId"}}`,
        encodeURIComponent(String(stationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (time !== undefined) {
        localVarQueryParameter["time"] = time;
      }

      if (interval !== undefined) {
        localVarQueryParameter["interval"] = interval;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given radar queue
     * @param {string} host LDM host
     * @param {number} [limit] Record limit
     * @param {ISO8601Interval} [arrived] Range for arrival time
     * @param {ISO8601Interval} [created] Range for creation time
     * @param {ISO8601Interval} [published] Range for publish time
     * @param {string} [station] Station identifier
     * @param {string} [type] Record type
     * @param {string} [feed] Originating product feed
     * @param {number} [resolution] Resolution version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarQueue(
      host: string,
      limit?: number,
      arrived?: ISO8601Interval,
      created?: ISO8601Interval,
      published?: ISO8601Interval,
      station?: string,
      type?: string,
      feed?: string,
      resolution?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'host' is not null or undefined
      if (host === null || host === undefined) {
        throw new RequiredError(
          "host",
          "Required parameter host was null or undefined when calling radarQueue."
        );
      }
      const localVarPath = `/radar/queues/{host}`.replace(
        `{${"host"}}`,
        encodeURIComponent(String(host))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (arrived !== undefined) {
        localVarQueryParameter["arrived"] = arrived;
      }

      if (created !== undefined) {
        localVarQueryParameter["created"] = created;
      }

      if (published !== undefined) {
        localVarQueryParameter["published"] = published;
      }

      if (station !== undefined) {
        localVarQueryParameter["station"] = station;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (feed !== undefined) {
        localVarQueryParameter["feed"] = feed;
      }

      if (resolution !== undefined) {
        localVarQueryParameter["resolution"] = resolution;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given radar server
     * @param {string} id Server ID
     * @param {string} [reportingHost] Show records from specific reporting host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarServer(
      id: string,
      reportingHost?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          "id",
          "Required parameter id was null or undefined when calling radarServer."
        );
      }
      const localVarPath = `/radar/servers/{id}`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (reportingHost !== undefined) {
        localVarQueryParameter["reportingHost"] = reportingHost;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of radar servers
     * @param {string} [reportingHost] Show records from specific reporting host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarServers(reportingHost?: string, options: any = {}): FetchArgs {
      const localVarPath = `/radar/servers`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (reportingHost !== undefined) {
        localVarQueryParameter["reportingHost"] = reportingHost;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given radar station
     * @param {string} stationId Radar station ID
     * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
     * @param {string} [host] Show latency info from specific LDM host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStation(
      stationId: string,
      reportingHost?: string,
      host?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling radarStation."
        );
      }
      const localVarPath = `/radar/stations/{stationId}`.replace(
        `{${"stationId"}}`,
        encodeURIComponent(String(stationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (reportingHost !== undefined) {
        localVarQueryParameter["reportingHost"] = reportingHost;
      }

      if (host !== undefined) {
        localVarQueryParameter["host"] = host;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given radar station alarms
     * @param {string} stationId Radar station ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStationAlarms(stationId: string, options: any = {}): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling radarStationAlarms."
        );
      }
      const localVarPath = `/radar/stations/{stationId}/alarms`.replace(
        `{${"stationId"}}`,
        encodeURIComponent(String(stationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of radar stations
     * @param {Array<string>} [stationType] Limit results to a specific station type or types
     * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
     * @param {string} [host] Show latency info from specific LDM host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStations(
      stationType?: Array<string>,
      reportingHost?: string,
      host?: string,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/radar/stations`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (stationType) {
        localVarQueryParameter["stationType"] = stationType.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (reportingHost !== undefined) {
        localVarQueryParameter["reportingHost"] = reportingHost;
      }

      if (host !== undefined) {
        localVarQueryParameter["host"] = host;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
     * @param {string} area .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    satelliteThumbnails(area: string, options: any = {}): FetchArgs {
      // verify required parameter 'area' is not null or undefined
      if (area === null || area === undefined) {
        throw new RequiredError(
          "area",
          "Required parameter area was null or undefined when calling satelliteThumbnails."
        );
      }
      const localVarPath = `/thumbnails/satellite/{area}`.replace(
        `{${"area"}}`,
        encodeURIComponent(String(area))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the latest observation for a station
     * @param {string} stationId Observation station ID
     * @param {boolean} [requireQc] Require QC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationLatest(
      stationId: string,
      requireQc?: boolean,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling stationObservationLatest."
        );
      }
      const localVarPath = `/stations/{stationId}/observations/latest`.replace(
        `{${"stationId"}}`,
        encodeURIComponent(String(stationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (requireQc !== undefined) {
        localVarQueryParameter["require_qc"] = requireQc;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of observations for a given station
     * @param {string} stationId Observation station ID
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationList(
      stationId: string,
      start?: Date,
      end?: Date,
      limit?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling stationObservationList."
        );
      }
      const localVarPath = `/stations/{stationId}/observations`.replace(
        `{${"stationId"}}`,
        encodeURIComponent(String(stationId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = (start as any).toISOString();
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = (end as any).toISOString();
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a single observation.
     * @param {string} stationId Observation station ID
     * @param {Date} time Timestamp of requested observation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationTime(
      stationId: string,
      time: Date,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'stationId' is not null or undefined
      if (stationId === null || stationId === undefined) {
        throw new RequiredError(
          "stationId",
          "Required parameter stationId was null or undefined when calling stationObservationTime."
        );
      }
      // verify required parameter 'time' is not null or undefined
      if (time === null || time === undefined) {
        throw new RequiredError(
          "time",
          "Required parameter time was null or undefined when calling stationObservationTime."
        );
      }
      const localVarPath = `/stations/{stationId}/observations/{time}`
        .replace(`{${"stationId"}}`, encodeURIComponent(String(stationId)))
        .replace(`{${"time"}}`, encodeURIComponent(String(time)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns metadata about a given zone
     * @param {string} type Zone type
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zone(
      type: string,
      zoneId: NWSZoneID,
      effective?: Date,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          "type",
          "Required parameter type was null or undefined when calling zone."
        );
      }
      // verify required parameter 'zoneId' is not null or undefined
      if (zoneId === null || zoneId === undefined) {
        throw new RequiredError(
          "zoneId",
          "Required parameter zoneId was null or undefined when calling zone."
        );
      }
      const localVarPath = `/zones/{type}/{zoneId}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (effective !== undefined) {
        localVarQueryParameter["effective"] = (effective as any).toISOString();
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the current zone forecast for a given zone
     * @param {string} type Zone type
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneForecast(
      type: string,
      zoneId: NWSZoneID,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          "type",
          "Required parameter type was null or undefined when calling zoneForecast."
        );
      }
      // verify required parameter 'zoneId' is not null or undefined
      if (zoneId === null || zoneId === undefined) {
        throw new RequiredError(
          "zoneId",
          "Required parameter zoneId was null or undefined when calling zoneForecast."
        );
      }
      const localVarPath = `/zones/{type}/{zoneId}/forecast`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of zones
     * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
     * @param {Array<AreaCode>} [area] State/marine area code
     * @param {Array<RegionCode>} [region] Region code
     * @param {Array<string>} [type] Zone type
     * @param {PointString} [point] Point (latitude,longitude)
     * @param {boolean} [includeGeometry] Include geometry in results (true/false)
     * @param {number} [limit] Limit
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneList(
      id?: Array<NWSZoneID>,
      area?: Array<AreaCode>,
      region?: Array<RegionCode>,
      type?: Array<string>,
      point?: PointString,
      includeGeometry?: boolean,
      limit?: number,
      effective?: Date,
      options: any = {}
    ): FetchArgs {
      const localVarPath = `/zones`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (id) {
        localVarQueryParameter["id"] = id.join(COLLECTION_FORMATS["csv"]);
      }

      if (area) {
        localVarQueryParameter["area"] = area.join(COLLECTION_FORMATS["csv"]);
      }

      if (region) {
        localVarQueryParameter["region"] = region.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (type) {
        localVarQueryParameter["type"] = type.join(COLLECTION_FORMATS["csv"]);
      }

      if (point !== undefined) {
        localVarQueryParameter["point"] = point;
      }

      if (includeGeometry !== undefined) {
        localVarQueryParameter["include_geometry"] = includeGeometry;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (effective !== undefined) {
        localVarQueryParameter["effective"] = (effective as any).toISOString();
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of zones of a given type
     * @param {string} type Zone type
     * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
     * @param {Array<AreaCode>} [area] State/marine area code
     * @param {Array<RegionCode>} [region] Region code
     * @param {Array<string>} [typeArray] Zone type
     * @param {PointString} [point] Point (latitude,longitude)
     * @param {boolean} [includeGeometry] Include geometry in results (true/false)
     * @param {number} [limit] Limit
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneListType(
      type: string,
      id?: Array<NWSZoneID>,
      area?: Array<AreaCode>,
      region?: Array<RegionCode>,
      typeArray?: Array<NWSZoneType>,
      point?: PointString,
      includeGeometry?: boolean,
      limit?: number,
      effective?: Date,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'type' is not null or undefined
      if (type === null || type === undefined) {
        throw new RequiredError(
          "type",
          "Required parameter type was null or undefined when calling zoneListType."
        );
      }
      const localVarPath = `/zones/{type}`.replace(
        `{${"type"}}`,
        encodeURIComponent(String(type))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (id) {
        localVarQueryParameter["id"] = id.join(COLLECTION_FORMATS["csv"]);
      }

      if (area) {
        localVarQueryParameter["area"] = area.join(COLLECTION_FORMATS["csv"]);
      }

      if (region) {
        localVarQueryParameter["region"] = region.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (typeArray) {
        localVarQueryParameter["type"] = typeArray.join(
          COLLECTION_FORMATS["csv"]
        );
      }

      if (point !== undefined) {
        localVarQueryParameter["point"] = point;
      }

      if (includeGeometry !== undefined) {
        localVarQueryParameter["include_geometry"] = includeGeometry;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (effective !== undefined) {
        localVarQueryParameter["effective"] = (effective as any).toISOString();
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of observations for a given zone
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {Date} [start] Start date/time
     * @param {Date} [end] End date/time
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneObs(
      zoneId: NWSZoneID,
      start?: Date,
      end?: Date,
      limit?: number,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'zoneId' is not null or undefined
      if (zoneId === null || zoneId === undefined) {
        throw new RequiredError(
          "zoneId",
          "Required parameter zoneId was null or undefined when calling zoneObs."
        );
      }
      const localVarPath = `/zones/forecast/{zoneId}/observations`.replace(
        `{${"zoneId"}}`,
        encodeURIComponent(String(zoneId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      if (start !== undefined) {
        localVarQueryParameter["start"] = (start as any).toISOString();
      }

      if (end !== undefined) {
        localVarQueryParameter["end"] = (end as any).toISOString();
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of observation stations for a given zone
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneStations(zoneId: NWSZoneID, options: any = {}): FetchArgs {
      // verify required parameter 'zoneId' is not null or undefined
      if (zoneId === null || zoneId === undefined) {
        throw new RequiredError(
          "zoneId",
          "Required parameter zoneId was null or undefined when calling zoneStations."
        );
      }
      const localVarPath = `/zones/forecast/{zoneId}/stations`.replace(
        `{${"zoneId"}}`,
        encodeURIComponent(String(zoneId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAgent required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("User-Agent")
            : configuration.apiKey;
        localVarHeaderParameter["User-Agent"] = localVarApiKeyValue;
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Returns all currently active alerts
     * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
     * @param {Array<string>} [messageType] Message type (alert, update, cancel)
     * @param {Array<string>} [event] Event name
     * @param {Array<string>} [code] Event code
     * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
     * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
     * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
     * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
     * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
     * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
     * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
     * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActive(
      status?: Array<string>,
      messageType?: Array<string>,
      event?: Array<string>,
      code?: Array<string>,
      area?: Array<AreaCode>,
      point?: PointString,
      region?: Array<MarineRegionCode>,
      regionType?: string,
      zone?: Array<NWSZoneID>,
      urgency?: Array<AlertUrgency>,
      severity?: Array<AlertSeverity>,
      certainty?: Array<AlertCertainty>,
      limit?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AlertCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).alertsActive(
        status,
        messageType,
        event,
        code,
        area,
        point,
        region,
        regionType,
        zone,
        urgency,
        severity,
        certainty,
        limit,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns active alerts for the given area (state or marine area)
     * @param {AreaCode} area State/area ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveArea(
      area: AreaCode,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AlertCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).alertsActiveArea(area, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        console.log(fetch);
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns info on the number of active alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveCount(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).alertsActiveCount(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns active alerts for the given marine region
     * @param {MarineRegionCode} region Marine region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveRegion(
      region: MarineRegionCode,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AlertCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).alertsActiveRegion(region, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns active alerts for the given NWS public zone or county
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveZone(
      zoneId: NWSZoneID,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AlertCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).alertsActiveZone(zoneId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns all alerts
     * @param {boolean} [active] List only active alerts (use /alerts/active endpoints instead)
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
     * @param {Array<string>} [messageType] Message type (alert, update, cancel)
     * @param {Array<string>} [event] Event name
     * @param {Array<string>} [code] Event code
     * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
     * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
     * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
     * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
     * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
     * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
     * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
     * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
     * @param {number} [limit] Limit
     * @param {string} [cursor] Pagination cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsQuery(
      active?: boolean,
      start?: Date,
      end?: Date,
      status?: Array<string>,
      messageType?: Array<string>,
      event?: Array<string>,
      code?: Array<string>,
      area?: Array<AreaCode>,
      point?: PointString,
      region?: Array<MarineRegionCode>,
      regionType?: string,
      zone?: Array<NWSZoneID>,
      urgency?: Array<AlertUrgency>,
      severity?: Array<AlertSeverity>,
      certainty?: Array<AlertCertainty>,
      limit?: number,
      cursor?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AlertCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).alertsQuery(
        active,
        start,
        end,
        status,
        messageType,
        event,
        code,
        area,
        point,
        region,
        regionType,
        zone,
        urgency,
        severity,
        certainty,
        limit,
        cursor,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a specific alert
     * @param {AlertId} id Alert identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsSingle(
      id: AlertId,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<AlertGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).alertsSingle(id, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of alert types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsTypes(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).alertsTypes(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns glossary terms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    glossary(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2002> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).glossary(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns raw numerical forecast data for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpoint(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<GridpointGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).gridpoint(wfo, x, y, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a textual forecast for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
     * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointForecast(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      featureFlags?: Array<string>,
      units?: GridpointForecastUnits,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<GridpointForecastGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).gridpointForecast(wfo, x, y, featureFlags, units, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a textual hourly forecast for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
     * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointForecastHourly(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      featureFlags?: Array<string>,
      units?: GridpointForecastUnits,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<GridpointForecastGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).gridpointForecastHourly(wfo, x, y, featureFlags, units, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of observation stations usable for a given 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointStations(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ObservationStationCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).gridpointStations(wfo, x, y, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {string} set .
     * @param {string} timeOfDay .
     * @param {string} first .
     * @param {Size} [size] Font size
     * @param {number} [fontsize] Font size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    icons(
      set: string,
      timeOfDay: string,
      first: string,
      size?: Size,
      fontsize?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BinaryFile> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).icons(set, timeOfDay, first, size, fontsize, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {string} set .
     * @param {string} timeOfDay .
     * @param {string} first .
     * @param {string} second .
     * @param {Size1} [size] Font size
     * @param {number} [fontsize] Font size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iconsDualCondition(
      set: string,
      timeOfDay: string,
      first: string,
      second: string,
      size?: Size1,
      fontsize?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BinaryFile> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).iconsDualCondition(
        set,
        timeOfDay,
        first,
        second,
        size,
        fontsize,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iconsSummary(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2003> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).iconsSummary(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of valid text product types for a given issuance location
     * @param {string} locationId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locationProducts(
      locationId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<TextProductTypeCollection> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).locationProducts(locationId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given observation station
     * @param {string} stationId Observation station ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obsStation(
      stationId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ObservationStationGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).obsStation(stationId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of observation stations.
     * @param {Array<string>} [id] Filter by observation station ID
     * @param {Array<AreaCode>} [state] Filter by state/marine area code
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obsStations(
      id?: Array<string>,
      state?: Array<AreaCode>,
      limit?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ObservationStationCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).obsStations(id, state, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a NWS forecast office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    office(
      officeId: NWSForecastOfficeId,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Office> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).office(officeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a specific news headline for a given NWS office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {string} headlineId Headline record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    officeHeadline(
      officeId: NWSForecastOfficeId,
      headlineId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<OfficeHeadline> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).officeHeadline(officeId, headlineId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of news headlines for a given NWS office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    officeHeadlines(
      officeId: NWSForecastOfficeId,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<OfficeHeadlineCollection> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).officeHeadlines(officeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given latitude/longitude point
     * @param {PointString} point Point (latitude, longitude)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    point(
      point: PointString,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<PointGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).point(point, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of observation stations for a given point
     * @param {PointString} point Point (latitude, longitude)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pointStations(
      point: PointString,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ProblemDetail> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).pointStations(point, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a specific text product
     * @param {string} productId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    product(
      productId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TextProduct> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).product(productId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of valid text product issuance locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productLocations(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<TextProductLocationCollection> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).productLocations(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of valid text product types and codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productTypes(
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<TextProductTypeCollection> {
      const localVarFetchArgs =
        DefaultApiFetchParamCreator(configuration).productTypes(options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of text products
     * @param {Array<string>} [location] Location id
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {Array<string>} [office] Issuing office
     * @param {Array<string>} [wmoid] WMO id code
     * @param {Array<string>} [type] Product code
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsQuery(
      location?: Array<string>,
      start?: Date,
      end?: Date,
      office?: Array<string>,
      wmoid?: Array<string>,
      type?: Array<string>,
      limit?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TextProductCollection> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).productsQuery(
        location,
        start,
        end,
        office,
        wmoid,
        type,
        limit,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of text products of a given type
     * @param {string} typeId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsType(
      typeId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TextProductCollection> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).productsType(typeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of text products of a given type for a given issuance location
     * @param {string} typeId .
     * @param {string} locationId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsTypeLocation(
      typeId: string,
      locationId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<TextProductCollection> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).productsTypeLocation(typeId, locationId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of valid text product issuance locations for a given product type
     * @param {string} typeId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsTypeLocations(
      typeId: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<TextProductLocationCollection> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).productsTypeLocations(typeId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given radar wind profiler
     * @param {string} stationId Profiler station ID
     * @param {ISO8601Interval} [time] Time interval
     * @param {ISO8601Duration} [interval] Averaging interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarProfiler(
      stationId: string,
      time?: ISO8601Interval,
      interval?: ISO8601Duration,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarProfiler(stationId, time, interval, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given radar queue
     * @param {string} host LDM host
     * @param {number} [limit] Record limit
     * @param {ISO8601Interval} [arrived] Range for arrival time
     * @param {ISO8601Interval} [created] Range for creation time
     * @param {ISO8601Interval} [published] Range for publish time
     * @param {string} [station] Station identifier
     * @param {string} [type] Record type
     * @param {string} [feed] Originating product feed
     * @param {number} [resolution] Resolution version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarQueue(
      host: string,
      limit?: number,
      arrived?: ISO8601Interval,
      created?: ISO8601Interval,
      published?: ISO8601Interval,
      station?: string,
      type?: string,
      feed?: string,
      resolution?: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarQueue(
        host,
        limit,
        arrived,
        created,
        published,
        station,
        type,
        feed,
        resolution,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given radar server
     * @param {string} id Server ID
     * @param {string} [reportingHost] Show records from specific reporting host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarServer(
      id: string,
      reportingHost?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarServer(id, reportingHost, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of radar servers
     * @param {string} [reportingHost] Show records from specific reporting host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarServers(
      reportingHost?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarServers(reportingHost, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given radar station
     * @param {string} stationId Radar station ID
     * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
     * @param {string} [host] Show latency info from specific LDM host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStation(
      stationId: string,
      reportingHost?: string,
      host?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarStation(stationId, reportingHost, host, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given radar station alarms
     * @param {string} stationId Radar station ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStationAlarms(
      stationId: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarStationAlarms(stationId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of radar stations
     * @param {Array<string>} [stationType] Limit results to a specific station type or types
     * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
     * @param {string} [host] Show latency info from specific LDM host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStations(
      stationType?: Array<string>,
      reportingHost?: string,
      host?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).radarStations(stationType, reportingHost, host, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
     * @param {string} area .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    satelliteThumbnails(
      area: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<BinaryFile> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).satelliteThumbnails(area, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the latest observation for a station
     * @param {string} stationId Observation station ID
     * @param {boolean} [requireQc] Require QC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationLatest(
      stationId: string,
      requireQc?: boolean,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ObservationGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).stationObservationLatest(stationId, requireQc, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of observations for a given station
     * @param {string} stationId Observation station ID
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationList(
      stationId: string,
      start?: Date,
      end?: Date,
      limit?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ObservationCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).stationObservationList(stationId, start, end, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a single observation.
     * @param {string} stationId Observation station ID
     * @param {Date} time Timestamp of requested observation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationTime(
      stationId: string,
      time: Date,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ObservationGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).stationObservationTime(stationId, time, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns metadata about a given zone
     * @param {string} type Zone type
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zone(
      type: string,
      zoneId: NWSZoneID,
      effective?: Date,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ZoneGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).zone(
        type,
        zoneId,
        effective,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns the current zone forecast for a given zone
     * @param {string} type Zone type
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneForecast(
      type: string,
      zoneId: NWSZoneID,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ZoneForecastGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).zoneForecast(type, zoneId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of zones
     * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
     * @param {Array<AreaCode>} [area] State/marine area code
     * @param {Array<RegionCode>} [region] Region code
     * @param {Array<string>} [type] Zone type
     * @param {PointString} [point] Point (latitude,longitude)
     * @param {boolean} [includeGeometry] Include geometry in results (true/false)
     * @param {number} [limit] Limit
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneList(
      id?: Array<NWSZoneID>,
      area?: Array<AreaCode>,
      region?: Array<RegionCode>,
      type?: Array<string>,
      point?: PointString,
      includeGeometry?: boolean,
      limit?: number,
      effective?: Date,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ZoneCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).zoneList(
        id,
        area,
        region,
        type,
        point,
        includeGeometry,
        limit,
        effective,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of zones of a given type
     * @param {string} type Zone type
     * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
     * @param {Array<AreaCode>} [area] State/marine area code
     * @param {Array<RegionCode>} [region] Region code
     * @param {Array<string>} [type] Zone type
     * @param {PointString} [point] Point (latitude,longitude)
     * @param {boolean} [includeGeometry] Include geometry in results (true/false)
     * @param {number} [limit] Limit
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneListType(
      type: string,
      id?: Array<NWSZoneID>,
      area?: Array<AreaCode>,
      region?: Array<RegionCode>,
      typeArray?: Array<NWSZoneType>,
      point?: PointString,
      includeGeometry?: boolean,
      limit?: number,
      effective?: Date,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<ZoneCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).zoneListType(
        type,
        id,
        area,
        region,
        typeArray,
        point,
        includeGeometry,
        limit,
        effective,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of observations for a given zone
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {Date} [start] Start date/time
     * @param {Date} [end] End date/time
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneObs(
      zoneId: NWSZoneID,
      start?: Date,
      end?: Date,
      limit?: number,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ObservationCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).zoneObs(zoneId, start, end, limit, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * Returns a list of observation stations for a given zone
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneStations(
      zoneId: NWSZoneID,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ObservationStationCollectionGeoJson> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).zoneStations(zoneId, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * Returns all currently active alerts
     * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
     * @param {Array<string>} [messageType] Message type (alert, update, cancel)
     * @param {Array<string>} [event] Event name
     * @param {Array<string>} [code] Event code
     * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
     * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
     * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
     * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
     * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
     * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
     * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
     * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActive(
      status?: Array<string>,
      messageType?: Array<string>,
      event?: Array<string>,
      code?: Array<string>,
      area?: Array<AreaCode>,
      point?: PointString,
      region?: Array<MarineRegionCode>,
      regionType?: string,
      zone?: Array<NWSZoneID>,
      urgency?: Array<AlertUrgency>,
      severity?: Array<AlertSeverity>,
      certainty?: Array<AlertCertainty>,
      limit?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).alertsActive(
        status,
        messageType,
        event,
        code,
        area,
        point,
        region,
        regionType,
        zone,
        urgency,
        severity,
        certainty,
        limit,
        options
      )(fetch, basePath);
    },
    /**
     * Returns active alerts for the given area (state or marine area)
     * @param {AreaCode} area State/area ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveArea(area: AreaCode, options?: any) {
      return DefaultApiFp(configuration).alertsActiveArea(area, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns info on the number of active alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveCount(options?: any) {
      return DefaultApiFp(configuration).alertsActiveCount(options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns active alerts for the given marine region
     * @param {MarineRegionCode} region Marine region ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveRegion(region: MarineRegionCode, options?: any) {
      return DefaultApiFp(configuration).alertsActiveRegion(region, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns active alerts for the given NWS public zone or county
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsActiveZone(zoneId: NWSZoneID, options?: any) {
      return DefaultApiFp(configuration).alertsActiveZone(zoneId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns all alerts
     * @param {boolean} [active] List only active alerts (use /alerts/active endpoints instead)
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
     * @param {Array<string>} [messageType] Message type (alert, update, cancel)
     * @param {Array<string>} [event] Event name
     * @param {Array<string>} [code] Event code
     * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
     * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
     * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
     * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
     * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
     * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
     * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
     * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
     * @param {number} [limit] Limit
     * @param {string} [cursor] Pagination cursor
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsQuery(
      active?: boolean,
      start?: Date,
      end?: Date,
      status?: Array<string>,
      messageType?: Array<string>,
      event?: Array<string>,
      code?: Array<string>,
      area?: Array<AreaCode>,
      point?: PointString,
      region?: Array<MarineRegionCode>,
      regionType?: string,
      zone?: Array<NWSZoneID>,
      urgency?: Array<AlertUrgency>,
      severity?: Array<AlertSeverity>,
      certainty?: Array<AlertCertainty>,
      limit?: number,
      cursor?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).alertsQuery(
        active,
        start,
        end,
        status,
        messageType,
        event,
        code,
        area,
        point,
        region,
        regionType,
        zone,
        urgency,
        severity,
        certainty,
        limit,
        cursor,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a specific alert
     * @param {AlertId} id Alert identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsSingle(id: AlertId, options?: any) {
      return DefaultApiFp(configuration).alertsSingle(id, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of alert types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    alertsTypes(options?: any) {
      return DefaultApiFp(configuration).alertsTypes(options)(fetch, basePath);
    },
    /**
     * Returns glossary terms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    glossary(options?: any) {
      return DefaultApiFp(configuration).glossary(options)(fetch, basePath);
    },
    /**
     * Returns raw numerical forecast data for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpoint(wfo: NWSForecastOfficeId, x: number, y: number, options?: any) {
      return DefaultApiFp(configuration).gridpoint(
        wfo,
        x,
        y,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a textual forecast for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
     * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointForecast(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      featureFlags?: Array<string>,
      units?: GridpointForecastUnits,
      options?: any
    ) {
      return DefaultApiFp(configuration).gridpointForecast(
        wfo,
        x,
        y,
        featureFlags,
        units,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a textual hourly forecast for a 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
     * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointForecastHourly(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      featureFlags?: Array<string>,
      units?: GridpointForecastUnits,
      options?: any
    ) {
      return DefaultApiFp(configuration).gridpointForecastHourly(
        wfo,
        x,
        y,
        featureFlags,
        units,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of observation stations usable for a given 2.5km grid area
     * @param {NWSForecastOfficeId} wfo Forecast office ID
     * @param {number} x Forecast grid X coordinate
     * @param {number} y Forecast grid Y coordinate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    gridpointStations(
      wfo: NWSForecastOfficeId,
      x: number,
      y: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).gridpointStations(
        wfo,
        x,
        y,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {string} set .
     * @param {string} timeOfDay .
     * @param {string} first .
     * @param {Size} [size] Font size
     * @param {number} [fontsize] Font size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    icons(
      set: string,
      timeOfDay: string,
      first: string,
      size?: Size,
      fontsize?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).icons(
        set,
        timeOfDay,
        first,
        size,
        fontsize,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a forecast icon. Icon services in API are deprecated.
     * @param {string} set .
     * @param {string} timeOfDay .
     * @param {string} first .
     * @param {string} second .
     * @param {Size1} [size] Font size
     * @param {number} [fontsize] Font size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iconsDualCondition(
      set: string,
      timeOfDay: string,
      first: string,
      second: string,
      size?: Size1,
      fontsize?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).iconsDualCondition(
        set,
        timeOfDay,
        first,
        second,
        size,
        fontsize,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iconsSummary(options?: any) {
      return DefaultApiFp(configuration).iconsSummary(options)(fetch, basePath);
    },
    /**
     * Returns a list of valid text product types for a given issuance location
     * @param {string} locationId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    locationProducts(locationId: string, options?: any) {
      return DefaultApiFp(configuration).locationProducts(locationId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns metadata about a given observation station
     * @param {string} stationId Observation station ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obsStation(stationId: string, options?: any) {
      return DefaultApiFp(configuration).obsStation(stationId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of observation stations.
     * @param {Array<string>} [id] Filter by observation station ID
     * @param {Array<AreaCode>} [state] Filter by state/marine area code
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    obsStations(
      id?: Array<string>,
      state?: Array<AreaCode>,
      limit?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).obsStations(
        id,
        state,
        limit,
        options
      )(fetch, basePath);
    },
    /**
     * Returns metadata about a NWS forecast office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    office(officeId: NWSForecastOfficeId, options?: any) {
      return DefaultApiFp(configuration).office(officeId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a specific news headline for a given NWS office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {string} headlineId Headline record ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    officeHeadline(
      officeId: NWSForecastOfficeId,
      headlineId: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).officeHeadline(
        officeId,
        headlineId,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of news headlines for a given NWS office
     * @param {NWSForecastOfficeId} officeId NWS forecast office ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    officeHeadlines(officeId: NWSForecastOfficeId, options?: any) {
      return DefaultApiFp(configuration).officeHeadlines(officeId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns metadata about a given latitude/longitude point
     * @param {PointString} point Point (latitude, longitude)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    point(point: PointString, options?: any) {
      return DefaultApiFp(configuration).point(point, options)(fetch, basePath);
    },
    /**
     * Returns a list of observation stations for a given point
     * @param {PointString} point Point (latitude, longitude)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pointStations(point: PointString, options?: any) {
      return DefaultApiFp(configuration).pointStations(point, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a specific text product
     * @param {string} productId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    product(productId: string, options?: any) {
      return DefaultApiFp(configuration).product(productId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of valid text product issuance locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productLocations(options?: any) {
      return DefaultApiFp(configuration).productLocations(options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of valid text product types and codes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productTypes(options?: any) {
      return DefaultApiFp(configuration).productTypes(options)(fetch, basePath);
    },
    /**
     * Returns a list of text products
     * @param {Array<string>} [location] Location id
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {Array<string>} [office] Issuing office
     * @param {Array<string>} [wmoid] WMO id code
     * @param {Array<string>} [type] Product code
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsQuery(
      location?: Array<string>,
      start?: Date,
      end?: Date,
      office?: Array<string>,
      wmoid?: Array<string>,
      type?: Array<string>,
      limit?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).productsQuery(
        location,
        start,
        end,
        office,
        wmoid,
        type,
        limit,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of text products of a given type
     * @param {string} typeId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsType(typeId: string, options?: any) {
      return DefaultApiFp(configuration).productsType(typeId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of text products of a given type for a given issuance location
     * @param {string} typeId .
     * @param {string} locationId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsTypeLocation(typeId: string, locationId: string, options?: any) {
      return DefaultApiFp(configuration).productsTypeLocation(
        typeId,
        locationId,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of valid text product issuance locations for a given product type
     * @param {string} typeId .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    productsTypeLocations(typeId: string, options?: any) {
      return DefaultApiFp(configuration).productsTypeLocations(typeId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns metadata about a given radar wind profiler
     * @param {string} stationId Profiler station ID
     * @param {ISO8601Interval} [time] Time interval
     * @param {ISO8601Duration} [interval] Averaging interval
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarProfiler(
      stationId: string,
      time?: ISO8601Interval,
      interval?: ISO8601Duration,
      options?: any
    ) {
      return DefaultApiFp(configuration).radarProfiler(
        stationId,
        time,
        interval,
        options
      )(fetch, basePath);
    },
    /**
     * Returns metadata about a given radar queue
     * @param {string} host LDM host
     * @param {number} [limit] Record limit
     * @param {ISO8601Interval} [arrived] Range for arrival time
     * @param {ISO8601Interval} [created] Range for creation time
     * @param {ISO8601Interval} [published] Range for publish time
     * @param {string} [station] Station identifier
     * @param {string} [type] Record type
     * @param {string} [feed] Originating product feed
     * @param {number} [resolution] Resolution version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarQueue(
      host: string,
      limit?: number,
      arrived?: ISO8601Interval,
      created?: ISO8601Interval,
      published?: ISO8601Interval,
      station?: string,
      type?: string,
      feed?: string,
      resolution?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).radarQueue(
        host,
        limit,
        arrived,
        created,
        published,
        station,
        type,
        feed,
        resolution,
        options
      )(fetch, basePath);
    },
    /**
     * Returns metadata about a given radar server
     * @param {string} id Server ID
     * @param {string} [reportingHost] Show records from specific reporting host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarServer(id: string, reportingHost?: string, options?: any) {
      return DefaultApiFp(configuration).radarServer(
        id,
        reportingHost,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of radar servers
     * @param {string} [reportingHost] Show records from specific reporting host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarServers(reportingHost?: string, options?: any) {
      return DefaultApiFp(configuration).radarServers(reportingHost, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns metadata about a given radar station
     * @param {string} stationId Radar station ID
     * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
     * @param {string} [host] Show latency info from specific LDM host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStation(
      stationId: string,
      reportingHost?: string,
      host?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).radarStation(
        stationId,
        reportingHost,
        host,
        options
      )(fetch, basePath);
    },
    /**
     * Returns metadata about a given radar station alarms
     * @param {string} stationId Radar station ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStationAlarms(stationId: string, options?: any) {
      return DefaultApiFp(configuration).radarStationAlarms(stationId, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns a list of radar stations
     * @param {Array<string>} [stationType] Limit results to a specific station type or types
     * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
     * @param {string} [host] Show latency info from specific LDM host
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    radarStations(
      stationType?: Array<string>,
      reportingHost?: string,
      host?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).radarStations(
        stationType,
        reportingHost,
        host,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
     * @param {string} area .
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    satelliteThumbnails(area: string, options?: any) {
      return DefaultApiFp(configuration).satelliteThumbnails(area, options)(
        fetch,
        basePath
      );
    },
    /**
     * Returns the latest observation for a station
     * @param {string} stationId Observation station ID
     * @param {boolean} [requireQc] Require QC
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationLatest(
      stationId: string,
      requireQc?: boolean,
      options?: any
    ) {
      return DefaultApiFp(configuration).stationObservationLatest(
        stationId,
        requireQc,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of observations for a given station
     * @param {string} stationId Observation station ID
     * @param {Date} [start] Start time
     * @param {Date} [end] End time
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationList(
      stationId: string,
      start?: Date,
      end?: Date,
      limit?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).stationObservationList(
        stationId,
        start,
        end,
        limit,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a single observation.
     * @param {string} stationId Observation station ID
     * @param {Date} time Timestamp of requested observation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stationObservationTime(stationId: string, time: Date, options?: any) {
      return DefaultApiFp(configuration).stationObservationTime(
        stationId,
        time,
        options
      )(fetch, basePath);
    },
    /**
     * Returns metadata about a given zone
     * @param {string} type Zone type
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zone(type: string, zoneId: NWSZoneID, effective?: Date, options?: any) {
      return DefaultApiFp(configuration).zone(
        type,
        zoneId,
        effective,
        options
      )(fetch, basePath);
    },
    /**
     * Returns the current zone forecast for a given zone
     * @param {string} type Zone type
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneForecast(type: string, zoneId: NWSZoneID, options?: any) {
      return DefaultApiFp(configuration).zoneForecast(
        type,
        zoneId,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of zones
     * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
     * @param {Array<AreaCode>} [area] State/marine area code
     * @param {Array<RegionCode>} [region] Region code
     * @param {Array<string>} [type] Zone type
     * @param {PointString} [point] Point (latitude,longitude)
     * @param {boolean} [includeGeometry] Include geometry in results (true/false)
     * @param {number} [limit] Limit
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneList(
      id?: Array<NWSZoneID>,
      area?: Array<AreaCode>,
      region?: Array<RegionCode>,
      type?: Array<string>,
      point?: PointString,
      includeGeometry?: boolean,
      limit?: number,
      effective?: Date,
      options?: any
    ) {
      return DefaultApiFp(configuration).zoneList(
        id,
        area,
        region,
        type,
        point,
        includeGeometry,
        limit,
        effective,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of zones of a given type
     * @param {string} type Zone type
     * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
     * @param {Array<AreaCode>} [area] State/marine area code
     * @param {Array<RegionCode>} [region] Region code
     * @param {Array<string>} [type] Zone type
     * @param {PointString} [point] Point (latitude,longitude)
     * @param {boolean} [includeGeometry] Include geometry in results (true/false)
     * @param {number} [limit] Limit
     * @param {Date} [effective] Effective date/time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneListType(
      type: string,
      id?: Array<NWSZoneID>,
      area?: Array<AreaCode>,
      region?: Array<RegionCode>,
      typeArray?: Array<NWSZoneType>,
      point?: PointString,
      includeGeometry?: boolean,
      limit?: number,
      effective?: Date,
      options?: any
    ) {
      return DefaultApiFp(configuration).zoneListType(
        type,
        id,
        area,
        region,
        typeArray,
        point,
        includeGeometry,
        limit,
        effective,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of observations for a given zone
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {Date} [start] Start date/time
     * @param {Date} [end] End date/time
     * @param {number} [limit] Limit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneObs(
      zoneId: NWSZoneID,
      start?: Date,
      end?: Date,
      limit?: number,
      options?: any
    ) {
      return DefaultApiFp(configuration).zoneObs(
        zoneId,
        start,
        end,
        limit,
        options
      )(fetch, basePath);
    },
    /**
     * Returns a list of observation stations for a given zone
     * @param {NWSZoneID} zoneId NWS public zone/county identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    zoneStations(zoneId: NWSZoneID, options?: any) {
      return DefaultApiFp(configuration).zoneStations(zoneId, options)(
        fetch,
        basePath
      );
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * Returns all currently active alerts
   * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
   * @param {Array<string>} [messageType] Message type (alert, update, cancel)
   * @param {Array<string>} [event] Event name
   * @param {Array<string>} [code] Event code
   * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
   * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
   * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
   * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
   * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
   * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
   * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
   * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
   * @param {number} [limit] Limit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsActive(
    status?: Array<string>,
    messageType?: Array<string>,
    event?: Array<string>,
    code?: Array<string>,
    area?: Array<AreaCode>,
    point?: PointString,
    region?: Array<MarineRegionCode>,
    regionType?: string,
    zone?: Array<NWSZoneID>,
    urgency?: Array<AlertUrgency>,
    severity?: Array<AlertSeverity>,
    certainty?: Array<AlertCertainty>,
    limit?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).alertsActive(
      status,
      messageType,
      event,
      code,
      area,
      point,
      region,
      regionType,
      zone,
      urgency,
      severity,
      certainty,
      limit,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns active alerts for the given area (state or marine area)
   * @param {AreaCode} area State/area ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsActiveArea(area: AreaCode, options?: any) {
    return DefaultApiFp(this.configuration).alertsActiveArea(area, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns info on the number of active alerts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsActiveCount(options?: any) {
    return DefaultApiFp(this.configuration).alertsActiveCount(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns active alerts for the given marine region
   * @param {MarineRegionCode} region Marine region ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsActiveRegion(region: MarineRegionCode, options?: any) {
    return DefaultApiFp(this.configuration).alertsActiveRegion(region, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns active alerts for the given NWS public zone or county
   * @param {NWSZoneID} zoneId NWS public zone/county identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsActiveZone(zoneId: NWSZoneID, options?: any) {
    return DefaultApiFp(this.configuration).alertsActiveZone(zoneId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns all alerts
   * @param {boolean} [active] List only active alerts (use /alerts/active endpoints instead)
   * @param {Date} [start] Start time
   * @param {Date} [end] End time
   * @param {Array<string>} [status] Status (actual, exercise, system, test, draft)
   * @param {Array<string>} [messageType] Message type (alert, update, cancel)
   * @param {Array<string>} [event] Event name
   * @param {Array<string>} [code] Event code
   * @param {Array<AreaCode>} [area] State/territory code or marine area code This parameter is incompatible with the following parameters: point, region, region_type, zone
   * @param {PointString} [point] Point (latitude,longitude) This parameter is incompatible with the following parameters: area, region, region_type, zone
   * @param {Array<MarineRegionCode>} [region] Marine region code This parameter is incompatible with the following parameters: area, point, region_type, zone
   * @param {string} [regionType] Region type (land or marine) This parameter is incompatible with the following parameters: area, point, region, zone
   * @param {Array<NWSZoneID>} [zone] Zone ID (forecast or county) This parameter is incompatible with the following parameters: area, point, region, region_type
   * @param {Array<AlertUrgency>} [urgency] Urgency (immediate, expected, future, past, unknown)
   * @param {Array<AlertSeverity>} [severity] Severity (extreme, severe, moderate, minor, unknown)
   * @param {Array<AlertCertainty>} [certainty] Certainty (observed, likely, possible, unlikely, unknown)
   * @param {number} [limit] Limit
   * @param {string} [cursor] Pagination cursor
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsQuery(
    active?: boolean,
    start?: Date,
    end?: Date,
    status?: Array<string>,
    messageType?: Array<string>,
    event?: Array<string>,
    code?: Array<string>,
    area?: Array<AreaCode>,
    point?: PointString,
    region?: Array<MarineRegionCode>,
    regionType?: string,
    zone?: Array<NWSZoneID>,
    urgency?: Array<AlertUrgency>,
    severity?: Array<AlertSeverity>,
    certainty?: Array<AlertCertainty>,
    limit?: number,
    cursor?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).alertsQuery(
      active,
      start,
      end,
      status,
      messageType,
      event,
      code,
      area,
      point,
      region,
      regionType,
      zone,
      urgency,
      severity,
      certainty,
      limit,
      cursor,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a specific alert
   * @param {AlertId} id Alert identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsSingle(id: AlertId, options?: any) {
    return DefaultApiFp(this.configuration).alertsSingle(id, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of alert types
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public alertsTypes(options?: any) {
    return DefaultApiFp(this.configuration).alertsTypes(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns glossary terms
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public glossary(options?: any) {
    return DefaultApiFp(this.configuration).glossary(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns raw numerical forecast data for a 2.5km grid area
   * @param {NWSForecastOfficeId} wfo Forecast office ID
   * @param {number} x Forecast grid X coordinate
   * @param {number} y Forecast grid Y coordinate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public gridpoint(
    wfo: NWSForecastOfficeId,
    x: number,
    y: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).gridpoint(
      wfo,
      x,
      y,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a textual forecast for a 2.5km grid area
   * @param {NWSForecastOfficeId} wfo Forecast office ID
   * @param {number} x Forecast grid X coordinate
   * @param {number} y Forecast grid Y coordinate
   * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
   * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public gridpointForecast(
    wfo: NWSForecastOfficeId,
    x: number,
    y: number,
    featureFlags?: Array<string>,
    units?: GridpointForecastUnits,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).gridpointForecast(
      wfo,
      x,
      y,
      featureFlags,
      units,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a textual hourly forecast for a 2.5km grid area
   * @param {NWSForecastOfficeId} wfo Forecast office ID
   * @param {number} x Forecast grid X coordinate
   * @param {number} y Forecast grid Y coordinate
   * @param {Array<string>} [featureFlags] Enable future and experimental features (see documentation for more info): * forecast_temperature_qv: Represent temperature as QuantitativeValue * forecast_wind_speed_qv: Represent wind speed as QuantitativeValue
   * @param {GridpointForecastUnits} [units] Use US customary or SI (metric) units in textual output
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public gridpointForecastHourly(
    wfo: NWSForecastOfficeId,
    x: number,
    y: number,
    featureFlags?: Array<string>,
    units?: GridpointForecastUnits,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).gridpointForecastHourly(
      wfo,
      x,
      y,
      featureFlags,
      units,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of observation stations usable for a given 2.5km grid area
   * @param {NWSForecastOfficeId} wfo Forecast office ID
   * @param {number} x Forecast grid X coordinate
   * @param {number} y Forecast grid Y coordinate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public gridpointStations(
    wfo: NWSForecastOfficeId,
    x: number,
    y: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).gridpointStations(
      wfo,
      x,
      y,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a forecast icon. Icon services in API are deprecated.
   * @param {string} set .
   * @param {string} timeOfDay .
   * @param {string} first .
   * @param {Size} [size] Font size
   * @param {number} [fontsize] Font size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public icons(
    set: string,
    timeOfDay: string,
    first: string,
    size?: Size,
    fontsize?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).icons(
      set,
      timeOfDay,
      first,
      size,
      fontsize,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a forecast icon. Icon services in API are deprecated.
   * @param {string} set .
   * @param {string} timeOfDay .
   * @param {string} first .
   * @param {string} second .
   * @param {Size1} [size] Font size
   * @param {number} [fontsize] Font size
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public iconsDualCondition(
    set: string,
    timeOfDay: string,
    first: string,
    second: string,
    size?: Size1,
    fontsize?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).iconsDualCondition(
      set,
      timeOfDay,
      first,
      second,
      size,
      fontsize,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of icon codes and textual descriptions. Icon services in API are deprecated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public iconsSummary(options?: any) {
    return DefaultApiFp(this.configuration).iconsSummary(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of valid text product types for a given issuance location
   * @param {string} locationId .
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public locationProducts(locationId: string, options?: any) {
    return DefaultApiFp(this.configuration).locationProducts(
      locationId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given observation station
   * @param {string} stationId Observation station ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public obsStation(stationId: string, options?: any) {
    return DefaultApiFp(this.configuration).obsStation(stationId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of observation stations.
   * @param {Array<string>} [id] Filter by observation station ID
   * @param {Array<AreaCode>} [state] Filter by state/marine area code
   * @param {number} [limit] Limit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public obsStations(
    id?: Array<string>,
    state?: Array<AreaCode>,
    limit?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).obsStations(
      id,
      state,
      limit,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a NWS forecast office
   * @param {NWSForecastOfficeId} officeId NWS forecast office ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public office(officeId: NWSForecastOfficeId, options?: any) {
    return DefaultApiFp(this.configuration).office(officeId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a specific news headline for a given NWS office
   * @param {NWSForecastOfficeId} officeId NWS forecast office ID
   * @param {string} headlineId Headline record ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public officeHeadline(
    officeId: NWSForecastOfficeId,
    headlineId: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).officeHeadline(
      officeId,
      headlineId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of news headlines for a given NWS office
   * @param {NWSForecastOfficeId} officeId NWS forecast office ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public officeHeadlines(officeId: NWSForecastOfficeId, options?: any) {
    return DefaultApiFp(this.configuration).officeHeadlines(officeId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns metadata about a given latitude/longitude point
   * @param {PointString} point Point (latitude, longitude)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public point(point: PointString, options?: any) {
    return DefaultApiFp(this.configuration).point(point, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of observation stations for a given point
   * @param {PointString} point Point (latitude, longitude)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public pointStations(point: PointString, options?: any) {
    return DefaultApiFp(this.configuration).pointStations(point, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a specific text product
   * @param {string} productId .
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public product(productId: string, options?: any) {
    return DefaultApiFp(this.configuration).product(productId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of valid text product issuance locations
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public productLocations(options?: any) {
    return DefaultApiFp(this.configuration).productLocations(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of valid text product types and codes
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public productTypes(options?: any) {
    return DefaultApiFp(this.configuration).productTypes(options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of text products
   * @param {Array<string>} [location] Location id
   * @param {Date} [start] Start time
   * @param {Date} [end] End time
   * @param {Array<string>} [office] Issuing office
   * @param {Array<string>} [wmoid] WMO id code
   * @param {Array<string>} [type] Product code
   * @param {number} [limit] Limit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public productsQuery(
    location?: Array<string>,
    start?: Date,
    end?: Date,
    office?: Array<string>,
    wmoid?: Array<string>,
    type?: Array<string>,
    limit?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).productsQuery(
      location,
      start,
      end,
      office,
      wmoid,
      type,
      limit,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of text products of a given type
   * @param {string} typeId .
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public productsType(typeId: string, options?: any) {
    return DefaultApiFp(this.configuration).productsType(typeId, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns a list of text products of a given type for a given issuance location
   * @param {string} typeId .
   * @param {string} locationId .
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public productsTypeLocation(
    typeId: string,
    locationId: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).productsTypeLocation(
      typeId,
      locationId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of valid text product issuance locations for a given product type
   * @param {string} typeId .
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public productsTypeLocations(typeId: string, options?: any) {
    return DefaultApiFp(this.configuration).productsTypeLocations(
      typeId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given radar wind profiler
   * @param {string} stationId Profiler station ID
   * @param {ISO8601Interval} [time] Time interval
   * @param {ISO8601Duration} [interval] Averaging interval
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarProfiler(
    stationId: string,
    time?: ISO8601Interval,
    interval?: ISO8601Duration,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).radarProfiler(
      stationId,
      time,
      interval,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given radar queue
   * @param {string} host LDM host
   * @param {number} [limit] Record limit
   * @param {ISO8601Interval} [arrived] Range for arrival time
   * @param {ISO8601Interval} [created] Range for creation time
   * @param {ISO8601Interval} [published] Range for publish time
   * @param {string} [station] Station identifier
   * @param {string} [type] Record type
   * @param {string} [feed] Originating product feed
   * @param {number} [resolution] Resolution version
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarQueue(
    host: string,
    limit?: number,
    arrived?: ISO8601Interval,
    created?: ISO8601Interval,
    published?: ISO8601Interval,
    station?: string,
    type?: string,
    feed?: string,
    resolution?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).radarQueue(
      host,
      limit,
      arrived,
      created,
      published,
      station,
      type,
      feed,
      resolution,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given radar server
   * @param {string} id Server ID
   * @param {string} [reportingHost] Show records from specific reporting host
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarServer(id: string, reportingHost?: string, options?: any) {
    return DefaultApiFp(this.configuration).radarServer(
      id,
      reportingHost,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of radar servers
   * @param {string} [reportingHost] Show records from specific reporting host
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarServers(reportingHost?: string, options?: any) {
    return DefaultApiFp(this.configuration).radarServers(
      reportingHost,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given radar station
   * @param {string} stationId Radar station ID
   * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
   * @param {string} [host] Show latency info from specific LDM host
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarStation(
    stationId: string,
    reportingHost?: string,
    host?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).radarStation(
      stationId,
      reportingHost,
      host,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given radar station alarms
   * @param {string} stationId Radar station ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarStationAlarms(stationId: string, options?: any) {
    return DefaultApiFp(this.configuration).radarStationAlarms(
      stationId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of radar stations
   * @param {Array<string>} [stationType] Limit results to a specific station type or types
   * @param {string} [reportingHost] Show RDA and latency info from specific reporting host
   * @param {string} [host] Show latency info from specific LDM host
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public radarStations(
    stationType?: Array<string>,
    reportingHost?: string,
    host?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).radarStations(
      stationType,
      reportingHost,
      host,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a thumbnail image for a satellite region. Image services in API are deprecated.
   * @param {string} area .
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public satelliteThumbnails(area: string, options?: any) {
    return DefaultApiFp(this.configuration).satelliteThumbnails(area, options)(
      this.fetch,
      this.basePath
    );
  }

  /**
   * Returns the latest observation for a station
   * @param {string} stationId Observation station ID
   * @param {boolean} [requireQc] Require QC
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public stationObservationLatest(
    stationId: string,
    requireQc?: boolean,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).stationObservationLatest(
      stationId,
      requireQc,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of observations for a given station
   * @param {string} stationId Observation station ID
   * @param {Date} [start] Start time
   * @param {Date} [end] End time
   * @param {number} [limit] Limit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public stationObservationList(
    stationId: string,
    start?: Date,
    end?: Date,
    limit?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).stationObservationList(
      stationId,
      start,
      end,
      limit,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a single observation.
   * @param {string} stationId Observation station ID
   * @param {Date} time Timestamp of requested observation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public stationObservationTime(stationId: string, time: Date, options?: any) {
    return DefaultApiFp(this.configuration).stationObservationTime(
      stationId,
      time,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns metadata about a given zone
   * @param {string} type Zone type
   * @param {NWSZoneID} zoneId NWS public zone/county identifier
   * @param {Date} [effective] Effective date/time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public zone(
    type: string,
    zoneId: NWSZoneID,
    effective?: Date,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).zone(
      type,
      zoneId,
      effective,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns the current zone forecast for a given zone
   * @param {string} type Zone type
   * @param {NWSZoneID} zoneId NWS public zone/county identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public zoneForecast(type: string, zoneId: NWSZoneID, options?: any) {
    return DefaultApiFp(this.configuration).zoneForecast(
      type,
      zoneId,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of zones
   * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
   * @param {Array<AreaCode>} [area] State/marine area code
   * @param {Array<RegionCode>} [region] Region code
   * @param {Array<string>} [type] Zone type
   * @param {PointString} [point] Point (latitude,longitude)
   * @param {boolean} [includeGeometry] Include geometry in results (true/false)
   * @param {number} [limit] Limit
   * @param {Date} [effective] Effective date/time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public zoneList(
    id?: Array<NWSZoneID>,
    area?: Array<AreaCode>,
    region?: Array<RegionCode>,
    type?: Array<string>,
    point?: PointString,
    includeGeometry?: boolean,
    limit?: number,
    effective?: Date,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).zoneList(
      id,
      area,
      region,
      type,
      point,
      includeGeometry,
      limit,
      effective,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of zones of a given type
   * @param {string} type Zone type
   * @param {Array<NWSZoneID>} [id] Zone ID (forecast or county)
   * @param {Array<AreaCode>} [area] State/marine area code
   * @param {Array<RegionCode>} [region] Region code
   * @param {Array<string>} [type] Zone type
   * @param {PointString} [point] Point (latitude,longitude)
   * @param {boolean} [includeGeometry] Include geometry in results (true/false)
   * @param {number} [limit] Limit
   * @param {Date} [effective] Effective date/time
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public zoneListType(
    type: string,
    id?: Array<NWSZoneID>,
    area?: Array<AreaCode>,
    region?: Array<RegionCode>,
    typeArray?: Array<NWSZoneType>,
    point?: PointString,
    includeGeometry?: boolean,
    limit?: number,
    effective?: Date,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).zoneListType(
      type,
      id,
      area,
      region,
      typeArray,
      point,
      includeGeometry,
      limit,
      effective,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of observations for a given zone
   * @param {NWSZoneID} zoneId NWS public zone/county identifier
   * @param {Date} [start] Start date/time
   * @param {Date} [end] End date/time
   * @param {number} [limit] Limit
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public zoneObs(
    zoneId: NWSZoneID,
    start?: Date,
    end?: Date,
    limit?: number,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).zoneObs(
      zoneId,
      start,
      end,
      limit,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * Returns a list of observation stations for a given zone
   * @param {NWSZoneID} zoneId NWS public zone/county identifier
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public zoneStations(zoneId: NWSZoneID, options?: any) {
    return DefaultApiFp(this.configuration).zoneStations(zoneId, options)(
      this.fetch,
      this.basePath
    );
  }
}
